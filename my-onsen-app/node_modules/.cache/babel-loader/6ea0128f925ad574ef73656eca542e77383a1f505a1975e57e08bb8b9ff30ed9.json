{"ast":null,"code":"/*\n * Gesture detector library that forked from github.com/EightMedia/hammer.js.\n */\n\n'use strict';\n\nimport \"core-js/modules/es.array.push.js\";\nimport util from './util.js';\nvar Event, Utils, Detection, PointerEvent;\n\n/**\n * @object ons.GestureDetector\n * @category gesture\n * @description\n *   [en]Utility class for gesture detection.[/en]\n *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]\n */\n\n/**\n * @method constructor\n * @signature constructor(element[, options])\n * @description\n *  [en]Create a new GestureDetector instance.[/en]\n *  [ja]GestureDetectorのインスタンスを生成します。[/ja]\n * @param {Element} element\n *   [en]Name of the event.[/en]\n *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]\n * @param {Object} [options]\n *   [en]Options object.[/en]\n *   [ja]オプションを指定します。[/ja]\n * @return {ons.GestureDetector.Instance}\n */\nvar GestureDetector = function GestureDetector(element, options) {\n  return new GestureDetector.Instance(element, options || {});\n};\n\n/**\n * default settings.\n * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled\n * by setting it's name (like `swipe`) to false.\n * You can set the defaults for all instances by changing this object before creating an instance.\n * @example\n * ````\n *  GestureDetector.defaults.drag = false;\n *  GestureDetector.defaults.behavior.touchAction = 'pan-y';\n *  delete GestureDetector.defaults.behavior.userSelect;\n * ````\n * @property defaults\n * @type {Object}\n */\nGestureDetector.defaults = {\n  behavior: {\n    // userSelect: 'none', // Also disables selection in `input` children\n    touchAction: 'pan-y',\n    touchCallout: 'none',\n    contentZooming: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * GestureDetector document where the base events are added at\n * @property DOCUMENT\n * @type {HTMLElement}\n * @default window.document\n */\nGestureDetector.DOCUMENT = document;\n\n/**\n * detect support for pointer events\n * @property HAS_POINTEREVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\n\n/**\n * detect support for touch events\n * @property HAS_TOUCHEVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;\n\n/**\n * detect mobile browsers\n * @property IS_MOBILE\n * @type {Boolean}\n */\nGestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);\n\n/**\n * detect if we want to support mouseevents at all\n * @property NO_MOUSEEVENTS\n * @type {Boolean}\n */\nGestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;\n\n/**\n * interval in which GestureDetector recalculates current velocity/direction/angle in ms\n * @property CALCULATE_INTERVAL\n * @type {Number}\n * @default 25\n */\nGestureDetector.CALCULATE_INTERVAL = 25;\n\n/**\n * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`\n * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)\n * @property EVENT_TYPES\n * @private\n * @writeOnce\n * @type {Object}\n */\nvar EVENT_TYPES = {};\n\n/**\n * direction strings, for safe comparisons\n * @property DIRECTION_DOWN|LEFT|UP|RIGHT\n * @final\n * @type {String}\n * @default 'down' 'left' 'up' 'right'\n */\nvar DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';\nvar DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';\nvar DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';\nvar DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';\n\n/**\n * pointertype strings, for safe comparisons\n * @property POINTER_MOUSE|TOUCH|PEN\n * @final\n * @type {String}\n * @default 'mouse' 'touch' 'pen'\n */\nvar POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';\nvar POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';\nvar POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';\n\n/**\n * eventtypes\n * @property EVENT_START|MOVE|END|RELEASE|TOUCH\n * @final\n * @type {String}\n * @default 'start' 'change' 'move' 'end' 'release' 'touch'\n */\nvar EVENT_START = GestureDetector.EVENT_START = 'start';\nvar EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';\nvar EVENT_END = GestureDetector.EVENT_END = 'end';\nvar EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';\nvar EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';\n\n/**\n * if the window events are set...\n * @property READY\n * @writeOnce\n * @type {Boolean}\n * @default false\n */\nGestureDetector.READY = false;\n\n/**\n * plugins namespace\n * @property plugins\n * @type {Object}\n */\nGestureDetector.plugins = GestureDetector.plugins || {};\n\n/**\n * gestures namespace\n * see `/gestures` for the definitions\n * @property gestures\n * @type {Object}\n */\nGestureDetector.gestures = GestureDetector.gestures || {};\n\n/**\n * setup events to detect gestures on the document\n * this function is called when creating an new instance\n * @private\n */\nfunction setup(opts) {\n  if (GestureDetector.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside GestureDetector.gestures\n  Utils.each(GestureDetector.gestures, function (gesture) {\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);\n\n  // GestureDetector is ready...!\n  GestureDetector.READY = true;\n}\n\n/**\n * @module GestureDetector\n *\n * @class Utils\n * @static\n */\nUtils = GestureDetector.utils = {\n  /**\n   * extend method, could also be used for cloning when `dest` is an empty object.\n   * changes the dest object\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]  do a merge\n   * @return {Object} dest\n   */\n  extend: function extend(dest, src, merge) {\n    for (var key in src) {\n      if (Object.prototype.hasOwnProperty.call(src, key) && (dest[key] === undefined || !merge)) {\n        dest[key] = src[key];\n      }\n    }\n    return dest;\n  },\n  /**\n   * simple addEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  on: function on(element, type, handler, opt) {\n    util.addEventListener(element, type, handler, opt, true);\n  },\n  /**\n   * simple removeEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  off: function off(element, type, handler, opt) {\n    util.removeEventListener(element, type, handler, opt, true);\n  },\n  /**\n   * forEach over arrays and objects\n   * @param {Object|Array} obj\n   * @param {Function} iterator\n   * @param {any} iterator.item\n   * @param {Number} iterator.index\n   * @param {Object|Array} iterator.obj the source object\n   * @param {Object} context value to use as `this` in the iterator\n   */\n  each: function each(obj, iterator, context) {\n    var i, len;\n\n    // native forEach on arrays\n    if ('forEach' in obj) {\n      obj.forEach(iterator, context);\n      // arrays\n    } else if (obj.length !== undefined) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n      // objects\n    } else {\n      for (i in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, i) && iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n  /**\n   * find if a string contains the string using indexOf\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean} found\n   */\n  inStr: function inStr(src, find) {\n    return src.indexOf(find) > -1;\n  },\n  /**\n   * find if a array contains the object using indexOf or a simple polyfill\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  inArray: function inArray(src, find, deep) {\n    if (deep) {\n      for (var i = 0, len = src.length; i < len; i++) {\n        // Array.findIndex\n        if (Object.keys(find).every(function (key) {\n          return src[i][key] === find[key];\n        })) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    if (src.indexOf) {\n      return src.indexOf(find);\n    } else {\n      for (var i = 0, len = src.length; i < len; i++) {\n        if (src[i] === find) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  },\n  /**\n   * convert an array-like object (`arguments`, `touchlist`) to an array\n   * @param {Object} obj\n   * @return {Array}\n   */\n  toArray: function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  },\n  /**\n   * find if a node is in the given parent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  hasParent: function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  },\n  /**\n   * get the center of all the touches\n   * @param {Array} touches\n   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties\n   */\n  getCenter: function getCenter(touches) {\n    var pageX = [],\n      pageY = [],\n      clientX = [],\n      clientY = [],\n      min = Math.min,\n      max = Math.max;\n\n    // no need to loop when only one touch\n    if (touches.length === 1) {\n      return {\n        pageX: touches[0].pageX,\n        pageY: touches[0].pageY,\n        clientX: touches[0].clientX,\n        clientY: touches[0].clientY\n      };\n    }\n    Utils.each(touches, function (touch) {\n      pageX.push(touch.pageX);\n      pageY.push(touch.pageY);\n      clientX.push(touch.clientX);\n      clientY.push(touch.clientY);\n    });\n    return {\n      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n    };\n  },\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   * @return {Object} velocity `x` and `y`\n   */\n  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {\n    return {\n      x: Math.abs(deltaX / deltaTime) || 0,\n      y: Math.abs(deltaY / deltaTime) || 0\n    };\n  },\n  /**\n   * calculate the angle between two coordinates\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {Number} angle\n   */\n  getAngle: function getAngle(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n      y = touch2.clientY - touch1.clientY;\n    return Math.atan2(y, x) * 180 / Math.PI;\n  },\n  /**\n   * do a small comparison to get the direction between two touches.\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`\n   */\n  getDirection: function getDirection(touch1, touch2) {\n    var x = Math.abs(touch1.clientX - touch2.clientX),\n      y = Math.abs(touch1.clientY - touch2.clientY);\n    if (x >= y) {\n      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  },\n  /**\n   * calculate the distance between two touches\n   * @param {Touch}touch1\n   * @param {Touch} touch2\n   * @return {Number} distance\n   */\n  getDistance: function getDistance(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n      y = touch2.clientY - touch1.clientY;\n    return Math.sqrt(x * x + y * y);\n  },\n  /**\n   * calculate the scale factor between two touchLists\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} scale\n   */\n  getScale: function getScale(start, end) {\n    // need two fingers...\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n    }\n    return 1;\n  },\n  /**\n   * calculate the rotation degrees between two touchLists\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} rotation\n   */\n  getRotation: function getRotation(start, end) {\n    // need two fingers\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n    }\n    return 0;\n  },\n  /**\n   * find out if the direction is vertical   *\n   * @param {String} direction matches `DIRECTION_UP|DOWN`\n   * @return {Boolean} is_vertical\n   */\n  isVertical: function isVertical(direction) {\n    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n  },\n  /**\n   * set css properties with their prefixes\n   * @param {HTMLElement} element\n   * @param {String} prop\n   * @param {String} value\n   * @param {Boolean} [toggle=true]\n   * @return {Boolean}\n   */\n  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    prop = Utils.toCamelCase(prop);\n    for (var i = 0; i < prefixes.length; i++) {\n      var p = prop;\n      // prefixes\n      if (prefixes[i]) {\n        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);\n      }\n\n      // test the style\n      if (p in element.style) {\n        element.style[p] = (toggle === null || toggle) && value || '';\n        break;\n      }\n    }\n  },\n  /**\n   * toggle browser default behavior by setting css properties.\n   * `userSelect='none'` also sets `element.onselectstart` to false\n   * `userDrag='none'` also sets `element.ondragstart` to false\n   *\n   * @param {HtmlElement} element\n   * @param {Object} props\n   * @param {Boolean} [toggle=true]\n   */\n  toggleBehavior: function toggleBehavior(element, props, toggle) {\n    if (!props || !element || !element.style) {\n      return;\n    }\n\n    // set the css properties\n    Utils.each(props, function (value, prop) {\n      Utils.setPrefixedCss(element, prop, value, toggle);\n    });\n    var falseFn = toggle && function () {\n      return false;\n    };\n\n    // also the disable onselectstart\n    if (props.userSelect == 'none') {\n      element.onselectstart = falseFn;\n    }\n    // and disable ondragstart\n    if (props.userDrag == 'none') {\n      element.ondragstart = falseFn;\n    }\n  },\n  /**\n   * convert a string with underscores to camelCase\n   * so prevent_default becomes preventDefault\n   * @param {String} str\n   * @return {String} camelCaseStr\n   */\n  toCamelCase: function toCamelCase(str) {\n    return str.replace(/[_-]([a-z])/g, function (s) {\n      return s[1].toUpperCase();\n    });\n  }\n};\n\n/**\n * @module GestureDetector\n */\n/**\n * @class Event\n * @static\n */\nEvent = GestureDetector.event = {\n  /**\n   * when touch events have been fired, this is true\n   * this is used to stop mouse events\n   * @property prevent_mouseevents\n   * @private\n   * @type {Boolean}\n   */\n  preventMouseEvents: false,\n  /**\n   * if EVENT_START has been fired\n   * @property started\n   * @private\n   * @type {Boolean}\n   */\n  started: false,\n  /**\n   * when the mouse is hold down, this is true\n   * @property should_detect\n   * @private\n   * @type {Boolean}\n   */\n  shouldDetect: false,\n  /**\n   * simple event binder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  on: function on(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function (type) {\n      Utils.on(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n  /**\n   * simple event unbinder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  off: function off(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function (type) {\n      Utils.off(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n  /**\n   * the core touch event handler.\n   * this finds out if we should to detect gestures\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Function} handler\n   * @return onTouchHandler {Function} the core event handler\n   */\n  onTouch: function onTouch(element, eventType, handler, opt) {\n    var self = this;\n    var onTouchHandler = function onTouchHandler(ev) {\n      var srcType = ev.type.toLowerCase(),\n        isPointer = GestureDetector.HAS_POINTEREVENTS,\n        isMouse = Utils.inStr(srcType, 'mouse'),\n        triggerType;\n\n      // if we are in a mouseevent, but there has been a touchevent triggered in this session\n      // we want to do nothing. simply break out of the event.\n      if (isMouse && self.preventMouseEvents) {\n        return;\n\n        // mousebutton must be down\n      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = true;\n      } else if (isPointer && eventType == EVENT_START) {\n        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);\n        // just a valid start event, but no mouse\n      } else if (!isMouse && eventType == EVENT_START) {\n        self.preventMouseEvents = true;\n        self.shouldDetect = true;\n      }\n\n      // update the pointer event before entering the detection\n      if (isPointer && eventType != EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n\n      // we are in a touch/down state, so allowed detection of gestures\n      if (self.shouldDetect) {\n        triggerType = self.doDetect.call(self, ev, eventType, element, handler);\n      }\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      if (triggerType == EVENT_END) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = false;\n        PointerEvent.reset();\n        // update the pointerevent object after the detection\n      }\n\n      if (isPointer && eventType == EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n    };\n    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);\n    return onTouchHandler;\n  },\n  /**\n   * the core detection method\n   * this finds out what GestureDetector-touch-events to trigger\n   * @param {Object} ev\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {HTMLElement} element\n   * @param {Function} handler\n   * @return {String} triggerType matches `EVENT_START|MOVE|END`\n   */\n  doDetect: function doDetect(ev, eventType, element, handler) {\n    var touchList = this.getTouchList(ev, eventType);\n    var touchListLength = touchList.length;\n    var triggerType = eventType;\n    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin\n    var changedLength = touchListLength;\n\n    // at each touchstart-like event we want also want to trigger a TOUCH event...\n    if (eventType == EVENT_START) {\n      triggerChange = EVENT_TOUCH;\n      // ...the same for a touchend-like event\n    } else if (eventType == EVENT_END) {\n      triggerChange = EVENT_RELEASE;\n\n      // keep track of how many touches have been removed\n      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);\n    }\n\n    // after there are still touches on the screen,\n    // we just want to trigger a MOVE event. so change the START or END to a MOVE\n    // but only after detection has been started, the first time we actually want a START\n    if (changedLength > 0 && this.started) {\n      triggerType = EVENT_MOVE;\n    }\n\n    // detection has been started, we keep track of this, see above\n    this.started = true;\n\n    // generate some event data, some basic information\n    var evData = this.collectEventData(element, triggerType, touchList, ev);\n\n    // trigger the triggerType event before the change (TOUCH, RELEASE) events\n    // but the END event should be at last\n    if (eventType != EVENT_END) {\n      handler.call(Detection, evData);\n    }\n\n    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed\n    if (triggerChange) {\n      evData.changedLength = changedLength;\n      evData.eventType = triggerChange;\n      handler.call(Detection, evData);\n      evData.eventType = triggerType;\n      delete evData.changedLength;\n    }\n\n    // trigger the END event\n    if (triggerType == EVENT_END) {\n      handler.call(Detection, evData);\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      this.started = false;\n    }\n    return triggerType;\n  },\n  /**\n   * we have different events for each device/browser\n   * determine what we need and set them in the EVENT_TYPES constant\n   * the `onTouch` method is bind to these properties.\n   * @return {Object} events\n   */\n  determineEventTypes: function determineEventTypes() {\n    var types;\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      if (window.PointerEvent) {\n        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];\n      } else {\n        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];\n      }\n    } else if (GestureDetector.NO_MOUSEEVENTS) {\n      types = ['touchstart', 'touchmove', 'touchend touchcancel'];\n    } else {\n      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];\n    }\n    EVENT_TYPES[EVENT_START] = types[0];\n    EVENT_TYPES[EVENT_MOVE] = types[1];\n    EVENT_TYPES[EVENT_END] = types[2];\n    return EVENT_TYPES;\n  },\n  /**\n   * create touchList depending on the event\n   * @param {Object} ev\n   * @param {String} eventType\n   * @return {Array} touches\n   */\n  getTouchList: function getTouchList(ev, eventType) {\n    // get the fake pointerEvent touchlist\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    }\n\n    // get the touchlist\n    if (ev.touches) {\n      if (eventType == EVENT_MOVE) {\n        return ev.touches;\n      }\n      var identifiers = [];\n      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));\n      var touchList = [];\n      Utils.each(concat, function (touch) {\n        if (Utils.inArray(identifiers, touch.identifier) === -1) {\n          touchList.push(touch);\n        }\n        identifiers.push(touch.identifier);\n      });\n      return touchList;\n    }\n\n    // make fake touchList from mouse position\n    ev.identifier = 1;\n    return [ev];\n  },\n  /**\n   * collect basic event data\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Array} touches\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  collectEventData: function collectEventData(element, eventType, touches, ev) {\n    // find out pointerType\n    var pointerType = POINTER_TOUCH;\n    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n      pointerType = POINTER_MOUSE;\n    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {\n      pointerType = POINTER_PEN;\n    }\n    return {\n      center: Utils.getCenter(touches),\n      timeStamp: Date.now(),\n      target: ev.target,\n      touches: touches,\n      eventType: eventType,\n      pointerType: pointerType,\n      srcEvent: ev,\n      /**\n       * prevent the browser default actions\n       * mostly used to disable scrolling of the browser\n       */\n      preventDefault: function () {\n        var srcEvent = this.srcEvent;\n        srcEvent.preventManipulation && srcEvent.preventManipulation();\n        srcEvent.preventDefault && srcEvent.preventDefault();\n      },\n      /**\n       * stop bubbling the event up to its parents\n       */\n      stopPropagation: function () {\n        this.srcEvent.stopPropagation();\n      },\n      /**\n       * immediately stop gesture detection\n       * might be useful after a swipe was detected\n       * @return {*}\n       */\n      stopDetect: function () {\n        return Detection.stopDetect();\n      }\n    };\n  }\n};\n\n/**\n * @module GestureDetector\n *\n * @class PointerEvent\n * @static\n */\nPointerEvent = GestureDetector.PointerEvent = {\n  /**\n   * holds all pointers, by `identifier`\n   * @property pointers\n   * @type {Object}\n   */\n  pointers: {},\n  /**\n   * get the pointers as an array\n   * @return {Array} touchlist\n   */\n  getTouchList: function getTouchList() {\n    var touchlist = [];\n    // we can use forEach since pointerEvents only is in IE10\n    Utils.each(this.pointers, function (pointer) {\n      touchlist.push(pointer);\n    });\n    return touchlist;\n  },\n  /**\n   * update the position of a pointer\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Object} pointerEvent\n   */\n  updatePointer: function updatePointer(eventType, pointerEvent) {\n    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {\n      delete this.pointers[pointerEvent.pointerId];\n    } else {\n      pointerEvent.identifier = pointerEvent.pointerId;\n      this.pointers[pointerEvent.pointerId] = pointerEvent;\n    }\n  },\n  /**\n   * check if ev matches pointertype\n   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`\n   * @param {PointerEvent} ev\n   */\n  matchType: function matchType(pointerType, ev) {\n    if (!ev.pointerType) {\n      return false;\n    }\n    var pt = ev.pointerType,\n      types = {};\n    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);\n    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);\n    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);\n    return types[pointerType];\n  },\n  /**\n   * reset the stored pointers\n   */\n  reset: function resetList() {\n    this.pointers = {};\n  }\n};\n\n/**\n * @module GestureDetector\n *\n * @class Detection\n * @static\n */\nDetection = GestureDetector.detection = {\n  // contains all registered GestureDetector.gestures in the correct order\n  gestures: [],\n  // data of the current GestureDetector.gesture detection session\n  current: null,\n  // the previous GestureDetector.gesture session data\n  // is a full clone of the previous gesture.current object\n  previous: null,\n  // when this becomes true, no gestures are fired\n  stopped: false,\n  /**\n   * start GestureDetector.gesture detection\n   * @param {GestureDetector.Instance} inst\n   * @param {Object} eventData\n   */\n  startDetect: function startDetect(inst, eventData) {\n    // already busy with a GestureDetector.gesture detection on an element\n    if (this.current) {\n      return;\n    }\n    this.stopped = false;\n\n    // holds current session\n    this.current = {\n      inst: inst,\n      // reference to GestureDetectorInstance we're working for\n      startEvent: Utils.extend({}, eventData),\n      // start eventData for distances, timing etc\n      lastEvent: false,\n      // last eventData\n      lastCalcEvent: false,\n      // last eventData for calculations.\n      futureCalcEvent: false,\n      // last eventData for calculations.\n      lastCalcData: {},\n      // last lastCalcData\n      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n    };\n\n    this.detect(eventData);\n  },\n  /**\n   * GestureDetector.gesture detection\n   * @param {Object} eventData\n   * @return {any}\n   */\n  detect: function detect(eventData) {\n    if (!this.current || this.stopped) {\n      return;\n    }\n\n    // extend event data with calculations about scale, distance etc\n    eventData = this.extendEventData(eventData);\n\n    // GestureDetector instance and instance options\n    var inst = this.current.inst,\n      instOptions = inst.options;\n\n    // call GestureDetector.gesture handlers\n    Utils.each(this.gestures, function triggerGesture(gesture) {\n      // only when the instance options have enabled this gesture\n      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {\n        gesture.handler.call(gesture, eventData, inst);\n      }\n    }, this);\n\n    // store as previous event event\n    if (this.current) {\n      this.current.lastEvent = eventData;\n    }\n    if (eventData.eventType == EVENT_END) {\n      this.stopDetect();\n    }\n    return eventData; // eslint-disable-line consistent-return\n  },\n\n  /**\n   * clear the GestureDetector.gesture vars\n   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected\n   * to stop other GestureDetector.gestures from being fired\n   */\n  stopDetect: function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Utils.extend({}, this.current);\n\n    // reset the current\n    this.current = null;\n    this.stopped = true;\n  },\n  /**\n   * calculate velocity, angle and direction\n   * @param {Object} ev\n   * @param {Object} center\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   */\n  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {\n    var cur = this.current,\n      recalc = false,\n      calcEv = cur.lastCalcEvent,\n      calcData = cur.lastCalcData;\n    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {\n      center = calcEv.center;\n      deltaTime = ev.timeStamp - calcEv.timeStamp;\n      deltaX = ev.center.clientX - calcEv.center.clientX;\n      deltaY = ev.center.clientY - calcEv.center.clientY;\n      recalc = true;\n    }\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      cur.futureCalcEvent = ev;\n    }\n    if (!cur.lastCalcEvent || recalc) {\n      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);\n      calcData.angle = Utils.getAngle(center, ev.center);\n      calcData.direction = Utils.getDirection(center, ev.center);\n      cur.lastCalcEvent = cur.futureCalcEvent || ev;\n      cur.futureCalcEvent = ev;\n    }\n    ev.velocityX = calcData.velocity.x;\n    ev.velocityY = calcData.velocity.y;\n    ev.interimAngle = calcData.angle;\n    ev.interimDirection = calcData.direction;\n  },\n  /**\n   * extend eventData for GestureDetector.gestures\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  extendEventData: function extendEventData(ev) {\n    var cur = this.current,\n      startEv = cur.startEvent,\n      lastEv = cur.lastEvent || startEv;\n\n    // update the start touchlist to calculate the scale/rotation\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      startEv.touches = [];\n      Utils.each(ev.touches, function (touch) {\n        startEv.touches.push({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n      });\n    }\n    var deltaTime = ev.timeStamp - startEv.timeStamp,\n      deltaX = ev.center.clientX - startEv.center.clientX,\n      deltaY = ev.center.clientY - startEv.center.clientY;\n    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);\n    Utils.extend(ev, {\n      startEvent: startEv,\n      deltaTime: deltaTime,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      distance: Utils.getDistance(startEv.center, ev.center),\n      angle: Utils.getAngle(startEv.center, ev.center),\n      direction: Utils.getDirection(startEv.center, ev.center),\n      scale: Utils.getScale(startEv.touches, ev.touches),\n      rotation: Utils.getRotation(startEv.touches, ev.touches)\n    });\n    return ev;\n  },\n  /**\n   * register new gesture\n   * @param {Object} gesture object, see `gestures/` for documentation\n   * @return {Array} gestures\n   */\n  register: function register(gesture) {\n    // add an enable gesture options if there is no given\n    var options = gesture.defaults || {};\n    if (options[gesture.name] === undefined) {\n      options[gesture.name] = true;\n    }\n\n    // extend GestureDetector default options with the GestureDetector.gesture options\n    Utils.extend(GestureDetector.defaults, options, true);\n\n    // set its index\n    gesture.index = gesture.index || 1000;\n\n    // add GestureDetector.gesture to the list\n    this.gestures.push(gesture);\n\n    // sort the list by index\n    this.gestures.sort(function (a, b) {\n      if (a.index < b.index) {\n        return -1;\n      }\n      if (a.index > b.index) {\n        return 1;\n      }\n      return 0;\n    });\n    return this.gestures;\n  }\n};\n\n/**\n * @module GestureDetector\n */\n\n/**\n * create new GestureDetector instance\n * all methods should return the instance itself, so it is chainable.\n *\n * @class Instance\n * @constructor\n * @param {HTMLElement} element\n * @param {Object} [options={}] options are merged with `GestureDetector.defaults`\n * @return {GestureDetector.Instance}\n */\nGestureDetector.Instance = function (element, options) {\n  var self = this;\n  var listenerOptions = options && options.passive ? {\n    passive: true\n  } : undefined;\n\n  // setup GestureDetectorJS window events and register all gestures\n  // this also sets up the default options\n  setup(listenerOptions);\n\n  /**\n   * @property element\n   * @type {HTMLElement}\n   */\n  this.element = element;\n\n  /**\n   * @property enabled\n   * @type {Boolean}\n   * @protected\n   */\n  this.enabled = true;\n\n  /**\n   * options, merged with the defaults\n   * options with an _ are converted to camelCase\n   * @property options\n   * @type {Object}\n   */\n  Utils.each(options, function (value, name) {\n    delete options[name];\n    options[Utils.toCamelCase(name)] = value;\n  });\n  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});\n  this.options.listenerOptions = listenerOptions;\n\n  // add some css to the element to prevent the browser from doing its native behavior\n  if (this.options.behavior) {\n    Utils.toggleBehavior(this.element, this.options.behavior, true);\n  }\n\n  /**\n   * event start handler on the element to start the detection\n   * @property eventStartHandler\n   * @type {Object}\n   */\n  this.eventStartHandler = Event.onTouch(element, EVENT_START, function (ev) {\n    if (self.enabled && ev.eventType == EVENT_START) {\n      Detection.startDetect(self, ev);\n    } else if (ev.eventType == EVENT_TOUCH) {\n      Detection.detect(ev);\n    }\n  }, listenerOptions);\n\n  /**\n   * keep a list of user event handlers which needs to be removed when calling 'dispose'\n   * @property eventHandlers\n   * @type {Array}\n   */\n  this.eventHandlers = [];\n};\nGestureDetector.Instance.prototype = {\n  /**\n   * @method on\n   * @signature on(gestures, handler)\n   * @description\n   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]\n   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  on: function onEvent(gestures, handler, opt) {\n    var self = this;\n    Event.on(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function (type) {\n      self.eventHandlers.push({\n        gesture: type,\n        handler: handler\n      });\n    });\n    return self;\n  },\n  /**\n   * @method off\n   * @signature off(gestures, handler)\n   * @description\n   *  [en]Remove an event listener.[/en]\n   *  [ja]イベントリスナーを削除します。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  off: function offEvent(gestures, handler, opt) {\n    var self = this;\n    Event.off(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function (type) {\n      var index = Utils.inArray(self.eventHandlers, {\n        gesture: type,\n        handler: handler\n      }, true);\n      if (index >= 0) {\n        self.eventHandlers.splice(index, 1);\n      }\n    });\n    return self;\n  },\n  /**\n   * trigger gesture event\n   * @method trigger\n   * @signature trigger(gesture, eventData)\n   * @param {String} gesture\n   * @param {Object} [eventData]\n   */\n  trigger: function triggerEvent(gesture, eventData) {\n    // optional\n    if (!eventData) {\n      eventData = {};\n    }\n\n    // create DOM event\n    var event = GestureDetector.DOCUMENT.createEvent('Event');\n    event.initEvent(gesture, true, true);\n    event.gesture = eventData;\n\n    // trigger on the target if it is in the instance element,\n    // this is for event delegation tricks\n    var element = this.element;\n    if (Utils.hasParent(eventData.target, element)) {\n      element = eventData.target;\n    }\n    element.dispatchEvent(event);\n    return this;\n  },\n  /**\n   * @method enable\n   * @signature enable(state)\n   * @description\n   *  [en]Enable or disable gesture detection.[/en]\n   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]\n   * @param {Boolean} state\n   *   [en]Specify if it should be enabled or not.[/en]\n   *   [ja]有効にするかどうかを指定します。[/ja]\n   */\n  enable: function enable(state) {\n    this.enabled = state;\n    return this;\n  },\n  /**\n   * @method dispose\n   * @signature dispose()\n   * @description\n   *  [en]Remove and destroy all event handlers for this instance.[/en]\n   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]\n   */\n  dispose: function dispose() {\n    var i, eh;\n\n    // undo all changes made by stop_browser_behavior\n    Utils.toggleBehavior(this.element, this.options.behavior, false);\n\n    // unbind all custom event handlers\n    for (i = -1; eh = this.eventHandlers[++i];) {\n      // eslint-disable-line no-cond-assign\n      Utils.off(this.element, eh.gesture, eh.handler);\n    }\n    this.eventHandlers = [];\n\n    // unbind the start event listener\n    Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);\n    return null;\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * Move with x fingers (default 1) around on the page.\n * Preventing the default browser behavior is a good way to improve feel and working.\n * ````\n *  GestureDetectortime.on(\"drag\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Drag\n * @static\n */\n/**\n * @event drag\n * @param {Object} ev\n */\n/**\n * @event dragstart\n * @param {Object} ev\n */\n/**\n * @event dragend\n * @param {Object} ev\n */\n/**\n * @event drapleft\n * @param {Object} ev\n */\n/**\n * @event dragright\n * @param {Object} ev\n */\n/**\n * @event dragup\n * @param {Object} ev\n */\n/**\n * @event dragdown\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var triggered = false;\n  function dragGesture(ev, inst) {\n    var cur = Detection.current;\n\n    // max touches\n    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {\n      return;\n    }\n    switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n      case EVENT_MOVE:\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {\n          return;\n        }\n        var startCenter = cur.startEvent.center;\n\n        // we are dragging!\n        if (cur.name != name) {\n          cur.name = name;\n          if (inst.options.dragDistanceCorrection && ev.distance > 0) {\n            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.\n            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.\n            // It might be useful to save the original start point somewhere\n            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);\n            startCenter.pageX += ev.deltaX * factor;\n            startCenter.pageY += ev.deltaY * factor;\n            startCenter.clientX += ev.deltaX * factor;\n            startCenter.clientY += ev.deltaY * factor;\n\n            // recalculate event data using new start point\n            ev = Detection.extendEventData(ev);\n          }\n        }\n\n        // lock drag to axis?\n        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {\n          ev.dragLockToAxis = true;\n        }\n\n        // keep direction on the axis that the drag gesture started on\n        var lastDirection = cur.lastEvent.direction;\n        if (ev.dragLockToAxis && lastDirection !== ev.direction) {\n          if (Utils.isVertical(lastDirection)) {\n            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          } else {\n            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          }\n        }\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        // trigger events\n        inst.trigger(name, ev);\n        inst.trigger(name + ev.direction, ev);\n        var isVertical = Utils.isVertical(ev.direction);\n\n        // block the browser events\n        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {\n          ev.preventDefault();\n        }\n        break;\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n      case EVENT_END:\n        triggered = false;\n        break;\n    }\n  }\n  GestureDetector.gestures.Drag = {\n    name: name,\n    index: 50,\n    handler: dragGesture,\n    defaults: {\n      /**\n       * minimal movement that have to be made before the drag event gets triggered\n       * @property dragMinDistance\n       * @type {Number}\n       * @default 10\n       */\n      dragMinDistance: 10,\n      /**\n       * Set dragDistanceCorrection to true to make the starting point of the drag\n       * be calculated from where the drag was triggered, not from where the touch started.\n       * Useful to avoid a jerk-starting drag, which can make fine-adjustments\n       * through dragging difficult, and be visually unappealing.\n       * @property dragDistanceCorrection\n       * @type {Boolean}\n       * @default true\n       */\n      dragDistanceCorrection: true,\n      /**\n       * set 0 for unlimited, but this can conflict with transform\n       * @property dragMaxTouches\n       * @type {Number}\n       * @default 1\n       */\n      dragMaxTouches: 1,\n      /**\n       * prevent default browser behavior when dragging occurs\n       * be careful with it, it makes the element a blocking element\n       * when you are using the drag gesture, it is a good practice to set this true\n       * @property dragBlockHorizontal\n       * @type {Boolean}\n       * @default false\n       */\n      dragBlockHorizontal: false,\n      /**\n       * same as `dragBlockHorizontal`, but for vertical movement\n       * @property dragBlockVertical\n       * @type {Boolean}\n       * @default false\n       */\n      dragBlockVertical: false,\n      /**\n       * dragLockToAxis keeps the drag gesture on the axis that it started on,\n       * It disallows vertical directions if the initial direction was horizontal, and vice versa.\n       * @property dragLockToAxis\n       * @type {Boolean}\n       * @default false\n       */\n      dragLockToAxis: false,\n      /**\n       * drag lock only kicks in when distance > dragLockMinDistance\n       * This way, locking occurs only when the distance has become large enough to reliably determine the direction\n       * @property dragLockMinDistance\n       * @type {Number}\n       * @default 25\n       */\n      dragLockMinDistance: 25\n    }\n  };\n})('drag');\n\n/**\n * @module gestures\n */\n/**\n * trigger a simple gesture event, so you can do anything in your handler.\n * only usable if you know what your doing...\n *\n * @class Gesture\n * @static\n */\n/**\n * @event gesture\n * @param {Object} ev\n */\nGestureDetector.gestures.Gesture = {\n  name: 'gesture',\n  index: 1337,\n  handler: function releaseGesture(ev, inst) {\n    inst.trigger(this.name, ev);\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * Touch stays at the same place for x time\n *\n * @class Hold\n * @static\n */\n/**\n * @event hold\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var timer;\n  function holdGesture(ev, inst) {\n    var options = inst.options,\n      current = Detection.current;\n    switch (ev.eventType) {\n      case EVENT_START:\n        clearTimeout(timer);\n\n        // set the gesture so we can check in the timeout if it still is\n        current.name = name;\n\n        // set timer and if after the timeout it still is hold,\n        // we trigger the hold event\n        timer = setTimeout(function () {\n          if (current && current.name == name) {\n            inst.trigger(name, ev);\n          }\n        }, options.holdTimeout);\n        break;\n      case EVENT_MOVE:\n        if (ev.distance > options.holdThreshold) {\n          clearTimeout(timer);\n        }\n        break;\n      case EVENT_RELEASE:\n        clearTimeout(timer);\n        break;\n    }\n  }\n  GestureDetector.gestures.Hold = {\n    name: name,\n    index: 10,\n    defaults: {\n      /**\n       * @property holdTimeout\n       * @type {Number}\n       * @default 500\n       */\n      holdTimeout: 500,\n      /**\n       * movement allowed while holding\n       * @property holdThreshold\n       * @type {Number}\n       * @default 2\n       */\n      holdThreshold: 2\n    },\n    handler: holdGesture\n  };\n})('hold');\n\n/**\n * @module gestures\n */\n/**\n * when a touch is being released from the page\n *\n * @class Release\n * @static\n */\n/**\n * @event release\n * @param {Object} ev\n */\nGestureDetector.gestures.Release = {\n  name: 'release',\n  index: Infinity,\n  handler: function releaseGesture(ev, inst) {\n    if (ev.eventType == EVENT_RELEASE) {\n      inst.trigger(this.name, ev);\n    }\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * triggers swipe events when the end velocity is above the threshold\n * for best usage, set `preventDefault` (on the drag gesture) to `true`\n * ````\n *  GestureDetectortime.on(\"dragleft swipeleft\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Swipe\n * @static\n */\n/**\n * @event swipe\n * @param {Object} ev\n */\n/**\n * @event swipeleft\n * @param {Object} ev\n */\n/**\n * @event swiperight\n * @param {Object} ev\n */\n/**\n * @event swipeup\n * @param {Object} ev\n */\n/**\n * @event swipedown\n * @param {Object} ev\n */\nGestureDetector.gestures.Swipe = {\n  name: 'swipe',\n  index: 40,\n  defaults: {\n    /**\n     * @property swipeMinTouches\n     * @type {Number}\n     * @default 1\n     */\n    swipeMinTouches: 1,\n    /**\n     * @property swipeMaxTouches\n     * @type {Number}\n     * @default 1\n     */\n    swipeMaxTouches: 1,\n    /**\n     * horizontal swipe velocity\n     * @property swipeVelocityX\n     * @type {Number}\n     * @default 0.6\n     */\n    swipeVelocityX: 0.6,\n    /**\n     * vertical swipe velocity\n     * @property swipeVelocityY\n     * @type {Number}\n     * @default 0.6\n     */\n    swipeVelocityY: 0.6\n  },\n  handler: function swipeGesture(ev, inst) {\n    if (ev.eventType == EVENT_RELEASE) {\n      var touches = ev.touches.length,\n        options = inst.options;\n\n      // max touches\n      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {\n        return;\n      }\n\n      // when the distance we moved is too small we skip this gesture\n      // or we can be already in dragging\n      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {\n        // trigger swipe events\n        inst.trigger(this.name, ev);\n        inst.trigger(this.name + ev.direction, ev);\n      }\n    }\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * Single tap and a double tap on a place\n *\n * @class Tap\n * @static\n */\n/**\n * @event tap\n * @param {Object} ev\n */\n/**\n * @event doubletap\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var hasMoved = false;\n  function tapGesture(ev, inst) {\n    var options = inst.options,\n      current = Detection.current,\n      prev = Detection.previous,\n      sincePrev,\n      didDoubleTap;\n    switch (ev.eventType) {\n      case EVENT_START:\n        hasMoved = false;\n        break;\n      case EVENT_MOVE:\n        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;\n        break;\n      case EVENT_END:\n        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {\n          // previous gesture, for the double tap since these are two different gesture detections\n          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n          didDoubleTap = false;\n\n          // check if double tap\n          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {\n            inst.trigger('doubletap', ev);\n            didDoubleTap = true;\n          }\n\n          // do a single tap\n          if (!didDoubleTap || options.tapAlways) {\n            current.name = name;\n            inst.trigger(current.name, ev);\n          }\n        }\n        break;\n    }\n  }\n  GestureDetector.gestures.Tap = {\n    name: name,\n    index: 100,\n    handler: tapGesture,\n    defaults: {\n      /**\n       * max time of a tap, this is for the slow tappers\n       * @property tapMaxTime\n       * @type {Number}\n       * @default 250\n       */\n      tapMaxTime: 250,\n      /**\n       * max distance of movement of a tap, this is for the slow tappers\n       * @property tapMaxDistance\n       * @type {Number}\n       * @default 10\n       */\n      tapMaxDistance: 10,\n      /**\n       * always trigger the `tap` event, even while double-tapping\n       * @property tapAlways\n       * @type {Boolean}\n       * @default true\n       */\n      tapAlways: true,\n      /**\n       * max distance between two taps\n       * @property doubleTapDistance\n       * @type {Number}\n       * @default 20\n       */\n      doubleTapDistance: 20,\n      /**\n       * max time between two taps\n       * @property doubleTapInterval\n       * @type {Number}\n       * @default 300\n       */\n      doubleTapInterval: 300\n    }\n  };\n})('tap');\n\n/**\n * @module gestures\n */\n/**\n * when a touch is being touched at the page\n *\n * @class Touch\n * @static\n */\n/**\n * @event touch\n * @param {Object} ev\n */\nGestureDetector.gestures.Touch = {\n  name: 'touch',\n  index: -Infinity,\n  defaults: {\n    /**\n     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,\n     * but it improves gestures like transforming and dragging.\n     * be careful with using this, it can be very annoying for users to be stuck on the page\n     * @property preventDefault\n     * @type {Boolean}\n     * @default false\n     */\n    preventDefault: false,\n    /**\n     * disable mouse events, so only touch (or pen!) input triggers events\n     * @property preventMouse\n     * @type {Boolean}\n     * @default false\n     */\n    preventMouse: false\n  },\n  handler: function touchGesture(ev, inst) {\n    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {\n      ev.stopDetect();\n      return;\n    }\n    if (inst.options.preventDefault) {\n      ev.preventDefault();\n    }\n    if (ev.eventType == EVENT_TOUCH) {\n      inst.trigger('touch', ev);\n    }\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * User want to scale or rotate with 2 fingers\n * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the\n * `preventDefault` option.\n *\n * @class Transform\n * @static\n */\n/**\n * @event transform\n * @param {Object} ev\n */\n/**\n * @event transformstart\n * @param {Object} ev\n */\n/**\n * @event transformend\n * @param {Object} ev\n */\n/**\n * @event pinchin\n * @param {Object} ev\n */\n/**\n * @event pinchout\n * @param {Object} ev\n */\n/**\n * @event rotate\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var triggered = false;\n  function transformGesture(ev, inst) {\n    switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n      case EVENT_MOVE:\n        // at least multitouch\n        if (ev.touches.length < 2) {\n          return;\n        }\n        var scaleThreshold = Math.abs(1 - ev.scale);\n        var rotationThreshold = Math.abs(ev.rotation);\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {\n          return;\n        }\n\n        // we are transforming!\n        Detection.current.name = name;\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n        inst.trigger(name, ev); // basic transform event\n\n        // trigger rotate event\n        if (rotationThreshold > inst.options.transformMinRotation) {\n          inst.trigger('rotate', ev);\n        }\n\n        // trigger pinch event\n        if (scaleThreshold > inst.options.transformMinScale) {\n          inst.trigger('pinch', ev);\n          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n        }\n        break;\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength < 2) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n    }\n  }\n  GestureDetector.gestures.Transform = {\n    name: name,\n    index: 45,\n    defaults: {\n      /**\n       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n       * @property transformMinScale\n       * @type {Number}\n       * @default 0.01\n       */\n      transformMinScale: 0.01,\n      /**\n       * rotation in degrees\n       * @property transformMinRotation\n       * @type {Number}\n       * @default 1\n       */\n      transformMinRotation: 1\n    },\n    handler: transformGesture\n  };\n})('transform');\nexport default GestureDetector;","map":{"version":3,"names":["util","Event","Utils","Detection","PointerEvent","GestureDetector","element","options","Instance","defaults","behavior","touchAction","touchCallout","contentZooming","userDrag","tapHighlightColor","DOCUMENT","document","HAS_POINTEREVENTS","navigator","pointerEnabled","msPointerEnabled","HAS_TOUCHEVENTS","window","IS_MOBILE","test","userAgent","NO_MOUSEEVENTS","CALCULATE_INTERVAL","EVENT_TYPES","DIRECTION_DOWN","DIRECTION_LEFT","DIRECTION_UP","DIRECTION_RIGHT","POINTER_MOUSE","POINTER_TOUCH","POINTER_PEN","EVENT_START","EVENT_MOVE","EVENT_END","EVENT_RELEASE","EVENT_TOUCH","READY","plugins","gestures","setup","opts","determineEventTypes","each","gesture","register","onTouch","detect","utils","extend","dest","src","merge","key","Object","prototype","hasOwnProperty","call","undefined","on","type","handler","opt","addEventListener","off","removeEventListener","obj","iterator","context","i","len","forEach","length","inStr","find","indexOf","inArray","deep","keys","every","toArray","Array","slice","hasParent","node","parent","parentNode","getCenter","touches","pageX","pageY","clientX","clientY","min","Math","max","touch","push","apply","getVelocity","deltaTime","deltaX","deltaY","x","abs","y","getAngle","touch1","touch2","atan2","PI","getDirection","getDistance","sqrt","getScale","start","end","getRotation","isVertical","direction","setPrefixedCss","prop","value","toggle","prefixes","toCamelCase","p","toUpperCase","style","toggleBehavior","props","falseFn","userSelect","onselectstart","ondragstart","str","replace","s","event","preventMouseEvents","started","shouldDetect","hook","types","split","eventType","self","onTouchHandler","ev","srcType","toLowerCase","isPointer","isMouse","triggerType","button","buttons","matchType","updatePointer","doDetect","reset","touchList","getTouchList","touchListLength","triggerChange","trigger","changedLength","changedTouches","evData","collectEventData","identifiers","concat","identifier","pointerType","center","timeStamp","Date","now","target","srcEvent","preventDefault","preventManipulation","stopPropagation","stopDetect","pointers","touchlist","pointer","pointerEvent","pointerId","pt","MSPOINTER_TYPE_MOUSE","MSPOINTER_TYPE_TOUCH","MSPOINTER_TYPE_PEN","resetList","detection","current","previous","stopped","startDetect","inst","eventData","startEvent","lastEvent","lastCalcEvent","futureCalcEvent","lastCalcData","name","extendEventData","instOptions","triggerGesture","enabled","getCalculatedData","cur","recalc","calcEv","calcData","velocity","angle","velocityX","velocityY","interimAngle","interimDirection","startEv","lastEv","distance","scale","rotation","index","sort","a","b","listenerOptions","passive","eventStartHandler","eventHandlers","onEvent","offEvent","splice","triggerEvent","createEvent","initEvent","dispatchEvent","enable","state","dispose","eh","triggered","dragGesture","dragMaxTouches","dragMinDistance","startCenter","dragDistanceCorrection","factor","dragLockToAxis","dragLockMinDistance","lastDirection","dragBlockVertical","dragBlockHorizontal","Drag","Gesture","releaseGesture","timer","holdGesture","clearTimeout","setTimeout","holdTimeout","holdThreshold","Hold","Release","Infinity","Swipe","swipeMinTouches","swipeMaxTouches","swipeVelocityX","swipeVelocityY","swipeGesture","hasMoved","tapGesture","prev","sincePrev","didDoubleTap","tapMaxDistance","tapMaxTime","doubleTapInterval","doubleTapDistance","tapAlways","Tap","Touch","preventMouse","touchGesture","transformGesture","scaleThreshold","rotationThreshold","transformMinScale","transformMinRotation","Transform"],"sources":["/Users/meenho/Documents/A_techlmh/vueTests/vueOnsenUITabMenuTestCode/my-onsen-app/node_modules/onsenui/esm/ons/gesture-detector.js"],"sourcesContent":["/*\n * Gesture detector library that forked from github.com/EightMedia/hammer.js.\n */\n\n'use strict';\n\nimport util from './util.js';\n\nvar Event, Utils, Detection, PointerEvent;\n\n/**\n * @object ons.GestureDetector\n * @category gesture\n * @description\n *   [en]Utility class for gesture detection.[/en]\n *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]\n */\n\n/**\n * @method constructor\n * @signature constructor(element[, options])\n * @description\n *  [en]Create a new GestureDetector instance.[/en]\n *  [ja]GestureDetectorのインスタンスを生成します。[/ja]\n * @param {Element} element\n *   [en]Name of the event.[/en]\n *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]\n * @param {Object} [options]\n *   [en]Options object.[/en]\n *   [ja]オプションを指定します。[/ja]\n * @return {ons.GestureDetector.Instance}\n */\nvar GestureDetector = function GestureDetector(element, options) {\n  return new GestureDetector.Instance(element, options || {});\n};\n\n\n/**\n * default settings.\n * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled\n * by setting it's name (like `swipe`) to false.\n * You can set the defaults for all instances by changing this object before creating an instance.\n * @example\n * ````\n *  GestureDetector.defaults.drag = false;\n *  GestureDetector.defaults.behavior.touchAction = 'pan-y';\n *  delete GestureDetector.defaults.behavior.userSelect;\n * ````\n * @property defaults\n * @type {Object}\n */\nGestureDetector.defaults = {\n  behavior: {\n    // userSelect: 'none', // Also disables selection in `input` children\n    touchAction: 'pan-y',\n    touchCallout: 'none',\n    contentZooming: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * GestureDetector document where the base events are added at\n * @property DOCUMENT\n * @type {HTMLElement}\n * @default window.document\n */\nGestureDetector.DOCUMENT = document;\n\n/**\n * detect support for pointer events\n * @property HAS_POINTEREVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\n\n/**\n * detect support for touch events\n * @property HAS_TOUCHEVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n/**\n * detect mobile browsers\n * @property IS_MOBILE\n * @type {Boolean}\n */\nGestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);\n\n/**\n * detect if we want to support mouseevents at all\n * @property NO_MOUSEEVENTS\n * @type {Boolean}\n */\nGestureDetector.NO_MOUSEEVENTS = (GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE) || GestureDetector.HAS_POINTEREVENTS;\n\n/**\n * interval in which GestureDetector recalculates current velocity/direction/angle in ms\n * @property CALCULATE_INTERVAL\n * @type {Number}\n * @default 25\n */\nGestureDetector.CALCULATE_INTERVAL = 25;\n\n/**\n * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`\n * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)\n * @property EVENT_TYPES\n * @private\n * @writeOnce\n * @type {Object}\n */\nvar EVENT_TYPES = {};\n\n/**\n * direction strings, for safe comparisons\n * @property DIRECTION_DOWN|LEFT|UP|RIGHT\n * @final\n * @type {String}\n * @default 'down' 'left' 'up' 'right'\n */\nvar DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';\nvar DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';\nvar DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';\nvar DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';\n\n/**\n * pointertype strings, for safe comparisons\n * @property POINTER_MOUSE|TOUCH|PEN\n * @final\n * @type {String}\n * @default 'mouse' 'touch' 'pen'\n */\nvar POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';\nvar POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';\nvar POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';\n\n/**\n * eventtypes\n * @property EVENT_START|MOVE|END|RELEASE|TOUCH\n * @final\n * @type {String}\n * @default 'start' 'change' 'move' 'end' 'release' 'touch'\n */\nvar EVENT_START = GestureDetector.EVENT_START = 'start';\nvar EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';\nvar EVENT_END = GestureDetector.EVENT_END = 'end';\nvar EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';\nvar EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';\n\n/**\n * if the window events are set...\n * @property READY\n * @writeOnce\n * @type {Boolean}\n * @default false\n */\nGestureDetector.READY = false;\n\n/**\n * plugins namespace\n * @property plugins\n * @type {Object}\n */\nGestureDetector.plugins = GestureDetector.plugins || {};\n\n/**\n * gestures namespace\n * see `/gestures` for the definitions\n * @property gestures\n * @type {Object}\n */\nGestureDetector.gestures = GestureDetector.gestures || {};\n\n/**\n * setup events to detect gestures on the document\n * this function is called when creating an new instance\n * @private\n */\nfunction setup(opts) {\n  if (GestureDetector.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside GestureDetector.gestures\n  Utils.each(GestureDetector.gestures, function(gesture) {\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);\n  Event.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);\n\n  // GestureDetector is ready...!\n  GestureDetector.READY = true;\n}\n\n/**\n * @module GestureDetector\n *\n * @class Utils\n * @static\n */\nUtils = GestureDetector.utils = {\n  /**\n   * extend method, could also be used for cloning when `dest` is an empty object.\n   * changes the dest object\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]  do a merge\n   * @return {Object} dest\n   */\n  extend: function extend(dest, src, merge) {\n    for (var key in src) {\n      if (Object.prototype.hasOwnProperty.call(src, key) && (dest[key] === undefined || !merge)) {\n        dest[key] = src[key];\n      }\n    }\n    return dest;\n  },\n\n  /**\n   * simple addEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  on: function on(element, type, handler, opt) {\n    util.addEventListener(element, type, handler, opt, true);\n  },\n\n  /**\n   * simple removeEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  off: function off(element, type, handler, opt) {\n    util.removeEventListener(element, type, handler, opt, true);\n  },\n\n  /**\n   * forEach over arrays and objects\n   * @param {Object|Array} obj\n   * @param {Function} iterator\n   * @param {any} iterator.item\n   * @param {Number} iterator.index\n   * @param {Object|Array} iterator.obj the source object\n   * @param {Object} context value to use as `this` in the iterator\n   */\n  each: function each(obj, iterator, context) {\n    var i, len;\n\n    // native forEach on arrays\n    if ('forEach' in obj) {\n      obj.forEach(iterator, context);\n      // arrays\n    } else if (obj.length !== undefined) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n      // objects\n    } else {\n      for (i in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, i) &&\n          iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  /**\n   * find if a string contains the string using indexOf\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean} found\n   */\n  inStr: function inStr(src, find) {\n    return src.indexOf(find) > -1;\n  },\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyfill\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  inArray: function inArray(src, find, deep) {\n    if (deep) {\n      for (var i = 0, len = src.length; i < len; i++) { // Array.findIndex\n        if (Object.keys(find).every(function(key) { return src[i][key] === find[key]; })) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    if (src.indexOf) {\n      return src.indexOf(find);\n    } else {\n      for (var i = 0, len = src.length; i < len; i++) {\n        if (src[i] === find) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  },\n\n  /**\n   * convert an array-like object (`arguments`, `touchlist`) to an array\n   * @param {Object} obj\n   * @return {Array}\n   */\n  toArray: function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  },\n\n  /**\n   * find if a node is in the given parent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  hasParent: function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  },\n\n  /**\n   * get the center of all the touches\n   * @param {Array} touches\n   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties\n   */\n  getCenter: function getCenter(touches) {\n    var pageX = [],\n        pageY = [],\n        clientX = [],\n        clientY = [],\n        min = Math.min,\n        max = Math.max;\n\n    // no need to loop when only one touch\n    if (touches.length === 1) {\n      return {\n        pageX: touches[0].pageX,\n        pageY: touches[0].pageY,\n        clientX: touches[0].clientX,\n        clientY: touches[0].clientY\n      };\n    }\n\n    Utils.each(touches, function(touch) {\n      pageX.push(touch.pageX);\n      pageY.push(touch.pageY);\n      clientX.push(touch.clientX);\n      clientY.push(touch.clientY);\n    });\n\n    return {\n      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n    };\n  },\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   * @return {Object} velocity `x` and `y`\n   */\n  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {\n    return {\n      x: Math.abs(deltaX / deltaTime) || 0,\n      y: Math.abs(deltaY / deltaTime) || 0\n    };\n  },\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {Number} angle\n   */\n  getAngle: function getAngle(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n\n    return Math.atan2(y, x) * 180 / Math.PI;\n  },\n\n  /**\n   * do a small comparison to get the direction between two touches.\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`\n   */\n  getDirection: function getDirection(touch1, touch2) {\n    var x = Math.abs(touch1.clientX - touch2.clientX),\n        y = Math.abs(touch1.clientY - touch2.clientY);\n\n    if (x >= y) {\n      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  },\n\n  /**\n   * calculate the distance between two touches\n   * @param {Touch}touch1\n   * @param {Touch} touch2\n   * @return {Number} distance\n   */\n  getDistance: function getDistance(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n\n    return Math.sqrt((x * x) + (y * y));\n  },\n\n  /**\n   * calculate the scale factor between two touchLists\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} scale\n   */\n  getScale: function getScale(start, end) {\n    // need two fingers...\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n    }\n    return 1;\n  },\n\n  /**\n   * calculate the rotation degrees between two touchLists\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} rotation\n   */\n  getRotation: function getRotation(start, end) {\n    // need two fingers\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n    }\n    return 0;\n  },\n\n  /**\n   * find out if the direction is vertical   *\n   * @param {String} direction matches `DIRECTION_UP|DOWN`\n   * @return {Boolean} is_vertical\n   */\n  isVertical: function isVertical(direction) {\n    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n  },\n\n  /**\n   * set css properties with their prefixes\n   * @param {HTMLElement} element\n   * @param {String} prop\n   * @param {String} value\n   * @param {Boolean} [toggle=true]\n   * @return {Boolean}\n   */\n  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    prop = Utils.toCamelCase(prop);\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var p = prop;\n      // prefixes\n      if (prefixes[i]) {\n        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);\n      }\n\n      // test the style\n      if (p in element.style) {\n        element.style[p] = (toggle === null || toggle) && value || '';\n        break;\n      }\n    }\n  },\n\n  /**\n   * toggle browser default behavior by setting css properties.\n   * `userSelect='none'` also sets `element.onselectstart` to false\n   * `userDrag='none'` also sets `element.ondragstart` to false\n   *\n   * @param {HtmlElement} element\n   * @param {Object} props\n   * @param {Boolean} [toggle=true]\n   */\n  toggleBehavior: function toggleBehavior(element, props, toggle) {\n    if (!props || !element || !element.style) {\n      return;\n    }\n\n    // set the css properties\n    Utils.each(props, function(value, prop) {\n      Utils.setPrefixedCss(element, prop, value, toggle);\n    });\n\n    var falseFn = toggle && function() {\n      return false;\n    };\n\n    // also the disable onselectstart\n    if (props.userSelect == 'none') {\n      element.onselectstart = falseFn;\n    }\n    // and disable ondragstart\n    if (props.userDrag == 'none') {\n      element.ondragstart = falseFn;\n    }\n  },\n\n  /**\n   * convert a string with underscores to camelCase\n   * so prevent_default becomes preventDefault\n   * @param {String} str\n   * @return {String} camelCaseStr\n   */\n  toCamelCase: function toCamelCase(str) {\n    return str.replace(/[_-]([a-z])/g, function(s) {\n      return s[1].toUpperCase();\n    });\n  }\n};\n\n\n/**\n * @module GestureDetector\n */\n/**\n * @class Event\n * @static\n */\nEvent = GestureDetector.event = {\n  /**\n   * when touch events have been fired, this is true\n   * this is used to stop mouse events\n   * @property prevent_mouseevents\n   * @private\n   * @type {Boolean}\n   */\n  preventMouseEvents: false,\n\n  /**\n   * if EVENT_START has been fired\n   * @property started\n   * @private\n   * @type {Boolean}\n   */\n  started: false,\n\n  /**\n   * when the mouse is hold down, this is true\n   * @property should_detect\n   * @private\n   * @type {Boolean}\n   */\n  shouldDetect: false,\n\n  /**\n   * simple event binder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  on: function on(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function(type) {\n      Utils.on(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * simple event unbinder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Object} [opt]\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  off: function off(element, type, handler, opt, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function(type) {\n      Utils.off(element, type, handler, opt);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * the core touch event handler.\n   * this finds out if we should to detect gestures\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Function} handler\n   * @return onTouchHandler {Function} the core event handler\n   */\n  onTouch: function onTouch(element, eventType, handler, opt) {\n    var self = this;\n\n    var onTouchHandler = function onTouchHandler(ev) {\n      var srcType = ev.type.toLowerCase(),\n          isPointer = GestureDetector.HAS_POINTEREVENTS,\n          isMouse = Utils.inStr(srcType, 'mouse'),\n          triggerType;\n\n      // if we are in a mouseevent, but there has been a touchevent triggered in this session\n      // we want to do nothing. simply break out of the event.\n      if (isMouse && self.preventMouseEvents) {\n        return;\n\n        // mousebutton must be down\n      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = true;\n      } else if (isPointer && eventType == EVENT_START) {\n        self.shouldDetect = (ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev));\n        // just a valid start event, but no mouse\n      } else if (!isMouse && eventType == EVENT_START) {\n        self.preventMouseEvents = true;\n        self.shouldDetect = true;\n      }\n\n      // update the pointer event before entering the detection\n      if (isPointer && eventType != EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n\n      // we are in a touch/down state, so allowed detection of gestures\n      if (self.shouldDetect) {\n        triggerType = self.doDetect.call(self, ev, eventType, element, handler);\n      }\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      if (triggerType == EVENT_END) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = false;\n        PointerEvent.reset();\n        // update the pointerevent object after the detection\n      }\n\n      if (isPointer && eventType == EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n    };\n\n    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);\n    return onTouchHandler;\n  },\n\n  /**\n   * the core detection method\n   * this finds out what GestureDetector-touch-events to trigger\n   * @param {Object} ev\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {HTMLElement} element\n   * @param {Function} handler\n   * @return {String} triggerType matches `EVENT_START|MOVE|END`\n   */\n  doDetect: function doDetect(ev, eventType, element, handler) {\n    var touchList = this.getTouchList(ev, eventType);\n    var touchListLength = touchList.length;\n    var triggerType = eventType;\n    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin\n    var changedLength = touchListLength;\n\n    // at each touchstart-like event we want also want to trigger a TOUCH event...\n    if (eventType == EVENT_START) {\n      triggerChange = EVENT_TOUCH;\n      // ...the same for a touchend-like event\n    } else if (eventType == EVENT_END) {\n      triggerChange = EVENT_RELEASE;\n\n      // keep track of how many touches have been removed\n      changedLength = touchList.length - ((ev.changedTouches) ? ev.changedTouches.length : 1);\n    }\n\n    // after there are still touches on the screen,\n    // we just want to trigger a MOVE event. so change the START or END to a MOVE\n    // but only after detection has been started, the first time we actually want a START\n    if (changedLength > 0 && this.started) {\n      triggerType = EVENT_MOVE;\n    }\n\n    // detection has been started, we keep track of this, see above\n    this.started = true;\n\n    // generate some event data, some basic information\n    var evData = this.collectEventData(element, triggerType, touchList, ev);\n\n    // trigger the triggerType event before the change (TOUCH, RELEASE) events\n    // but the END event should be at last\n    if (eventType != EVENT_END) {\n      handler.call(Detection, evData);\n    }\n\n    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed\n    if (triggerChange) {\n      evData.changedLength = changedLength;\n      evData.eventType = triggerChange;\n\n      handler.call(Detection, evData);\n\n      evData.eventType = triggerType;\n      delete evData.changedLength;\n    }\n\n    // trigger the END event\n    if (triggerType == EVENT_END) {\n      handler.call(Detection, evData);\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      this.started = false;\n    }\n\n    return triggerType;\n  },\n\n  /**\n   * we have different events for each device/browser\n   * determine what we need and set them in the EVENT_TYPES constant\n   * the `onTouch` method is bind to these properties.\n   * @return {Object} events\n   */\n  determineEventTypes: function determineEventTypes() {\n    var types;\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      if (window.PointerEvent) {\n        types = [\n          'pointerdown',\n          'pointermove',\n          'pointerup pointercancel lostpointercapture'\n        ];\n      } else {\n        types = [\n          'MSPointerDown',\n          'MSPointerMove',\n          'MSPointerUp MSPointerCancel MSLostPointerCapture'\n        ];\n      }\n    } else if (GestureDetector.NO_MOUSEEVENTS) {\n      types = [\n        'touchstart',\n        'touchmove',\n        'touchend touchcancel'\n      ];\n    } else {\n      types = [\n        'touchstart mousedown',\n        'touchmove mousemove',\n        'touchend touchcancel mouseup'\n      ];\n    }\n\n    EVENT_TYPES[EVENT_START] = types[0];\n    EVENT_TYPES[EVENT_MOVE] = types[1];\n    EVENT_TYPES[EVENT_END] = types[2];\n    return EVENT_TYPES;\n  },\n\n  /**\n   * create touchList depending on the event\n   * @param {Object} ev\n   * @param {String} eventType\n   * @return {Array} touches\n   */\n  getTouchList: function getTouchList(ev, eventType) {\n    // get the fake pointerEvent touchlist\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    }\n\n    // get the touchlist\n    if (ev.touches) {\n      if (eventType == EVENT_MOVE) {\n        return ev.touches;\n      }\n\n      var identifiers = [];\n      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));\n      var touchList = [];\n\n      Utils.each(concat, function(touch) {\n        if (Utils.inArray(identifiers, touch.identifier) === -1) {\n          touchList.push(touch);\n        }\n        identifiers.push(touch.identifier);\n      });\n\n      return touchList;\n    }\n\n    // make fake touchList from mouse position\n    ev.identifier = 1;\n    return [ev];\n  },\n\n  /**\n   * collect basic event data\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Array} touches\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  collectEventData: function collectEventData(element, eventType, touches, ev) {\n    // find out pointerType\n    var pointerType = POINTER_TOUCH;\n    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n      pointerType = POINTER_MOUSE;\n    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {\n      pointerType = POINTER_PEN;\n    }\n\n    return {\n      center: Utils.getCenter(touches),\n      timeStamp: Date.now(),\n      target: ev.target,\n      touches: touches,\n      eventType: eventType,\n      pointerType: pointerType,\n      srcEvent: ev,\n\n      /**\n       * prevent the browser default actions\n       * mostly used to disable scrolling of the browser\n       */\n      preventDefault: function() {\n        var srcEvent = this.srcEvent;\n        srcEvent.preventManipulation && srcEvent.preventManipulation();\n        srcEvent.preventDefault && srcEvent.preventDefault();\n      },\n\n      /**\n       * stop bubbling the event up to its parents\n       */\n      stopPropagation: function() {\n        this.srcEvent.stopPropagation();\n      },\n\n      /**\n       * immediately stop gesture detection\n       * might be useful after a swipe was detected\n       * @return {*}\n       */\n      stopDetect: function() {\n        return Detection.stopDetect();\n      }\n    };\n  }\n};\n\n\n/**\n * @module GestureDetector\n *\n * @class PointerEvent\n * @static\n */\nPointerEvent = GestureDetector.PointerEvent = {\n  /**\n   * holds all pointers, by `identifier`\n   * @property pointers\n   * @type {Object}\n   */\n  pointers: {},\n\n  /**\n   * get the pointers as an array\n   * @return {Array} touchlist\n   */\n  getTouchList: function getTouchList() {\n    var touchlist = [];\n    // we can use forEach since pointerEvents only is in IE10\n    Utils.each(this.pointers, function(pointer) {\n      touchlist.push(pointer);\n    });\n    return touchlist;\n  },\n\n  /**\n   * update the position of a pointer\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Object} pointerEvent\n   */\n  updatePointer: function updatePointer(eventType, pointerEvent) {\n    if (eventType == EVENT_END || (eventType != EVENT_END && pointerEvent.buttons !== 1)) {\n      delete this.pointers[pointerEvent.pointerId];\n    } else {\n      pointerEvent.identifier = pointerEvent.pointerId;\n      this.pointers[pointerEvent.pointerId] = pointerEvent;\n    }\n  },\n\n  /**\n   * check if ev matches pointertype\n   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`\n   * @param {PointerEvent} ev\n   */\n  matchType: function matchType(pointerType, ev) {\n    if (!ev.pointerType) {\n      return false;\n    }\n\n    var pt = ev.pointerType,\n        types = {};\n\n    types[POINTER_MOUSE] = (pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE));\n    types[POINTER_TOUCH] = (pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH));\n    types[POINTER_PEN] = (pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN));\n    return types[pointerType];\n  },\n\n  /**\n   * reset the stored pointers\n   */\n  reset: function resetList() {\n    this.pointers = {};\n  }\n};\n\n\n/**\n * @module GestureDetector\n *\n * @class Detection\n * @static\n */\nDetection = GestureDetector.detection = {\n  // contains all registered GestureDetector.gestures in the correct order\n  gestures: [],\n\n  // data of the current GestureDetector.gesture detection session\n  current: null,\n\n  // the previous GestureDetector.gesture session data\n  // is a full clone of the previous gesture.current object\n  previous: null,\n\n  // when this becomes true, no gestures are fired\n  stopped: false,\n\n  /**\n   * start GestureDetector.gesture detection\n   * @param {GestureDetector.Instance} inst\n   * @param {Object} eventData\n   */\n  startDetect: function startDetect(inst, eventData) {\n    // already busy with a GestureDetector.gesture detection on an element\n    if (this.current) {\n      return;\n    }\n\n    this.stopped = false;\n\n    // holds current session\n    this.current = {\n      inst: inst, // reference to GestureDetectorInstance we're working for\n      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc\n      lastEvent: false, // last eventData\n      lastCalcEvent: false, // last eventData for calculations.\n      futureCalcEvent: false, // last eventData for calculations.\n      lastCalcData: {}, // last lastCalcData\n      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n    };\n\n    this.detect(eventData);\n  },\n\n  /**\n   * GestureDetector.gesture detection\n   * @param {Object} eventData\n   * @return {any}\n   */\n  detect: function detect(eventData) {\n    if (!this.current || this.stopped) {\n      return;\n    }\n\n    // extend event data with calculations about scale, distance etc\n    eventData = this.extendEventData(eventData);\n\n    // GestureDetector instance and instance options\n    var inst = this.current.inst,\n        instOptions = inst.options;\n\n    // call GestureDetector.gesture handlers\n    Utils.each(this.gestures, function triggerGesture(gesture) {\n      // only when the instance options have enabled this gesture\n      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {\n        gesture.handler.call(gesture, eventData, inst);\n      }\n    }, this);\n\n    // store as previous event event\n    if (this.current) {\n      this.current.lastEvent = eventData;\n    }\n\n    if (eventData.eventType == EVENT_END) {\n      this.stopDetect();\n    }\n\n    return eventData; // eslint-disable-line consistent-return\n  },\n\n  /**\n   * clear the GestureDetector.gesture vars\n   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected\n   * to stop other GestureDetector.gestures from being fired\n   */\n  stopDetect: function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Utils.extend({}, this.current);\n\n    // reset the current\n    this.current = null;\n    this.stopped = true;\n  },\n\n  /**\n   * calculate velocity, angle and direction\n   * @param {Object} ev\n   * @param {Object} center\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   */\n  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {\n    var cur = this.current,\n        recalc = false,\n        calcEv = cur.lastCalcEvent,\n        calcData = cur.lastCalcData;\n\n    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {\n      center = calcEv.center;\n      deltaTime = ev.timeStamp - calcEv.timeStamp;\n      deltaX = ev.center.clientX - calcEv.center.clientX;\n      deltaY = ev.center.clientY - calcEv.center.clientY;\n      recalc = true;\n    }\n\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      cur.futureCalcEvent = ev;\n    }\n\n    if (!cur.lastCalcEvent || recalc) {\n      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);\n      calcData.angle = Utils.getAngle(center, ev.center);\n      calcData.direction = Utils.getDirection(center, ev.center);\n\n      cur.lastCalcEvent = cur.futureCalcEvent || ev;\n      cur.futureCalcEvent = ev;\n    }\n\n    ev.velocityX = calcData.velocity.x;\n    ev.velocityY = calcData.velocity.y;\n    ev.interimAngle = calcData.angle;\n    ev.interimDirection = calcData.direction;\n  },\n\n  /**\n   * extend eventData for GestureDetector.gestures\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  extendEventData: function extendEventData(ev) {\n    var cur = this.current,\n        startEv = cur.startEvent,\n        lastEv = cur.lastEvent || startEv;\n\n    // update the start touchlist to calculate the scale/rotation\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      startEv.touches = [];\n      Utils.each(ev.touches, function(touch) {\n        startEv.touches.push({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n      });\n    }\n\n    var deltaTime = ev.timeStamp - startEv.timeStamp,\n        deltaX = ev.center.clientX - startEv.center.clientX,\n        deltaY = ev.center.clientY - startEv.center.clientY;\n\n    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);\n\n    Utils.extend(ev, {\n      startEvent: startEv,\n\n      deltaTime: deltaTime,\n      deltaX: deltaX,\n      deltaY: deltaY,\n\n      distance: Utils.getDistance(startEv.center, ev.center),\n      angle: Utils.getAngle(startEv.center, ev.center),\n      direction: Utils.getDirection(startEv.center, ev.center),\n      scale: Utils.getScale(startEv.touches, ev.touches),\n      rotation: Utils.getRotation(startEv.touches, ev.touches)\n    });\n\n    return ev;\n  },\n\n  /**\n   * register new gesture\n   * @param {Object} gesture object, see `gestures/` for documentation\n   * @return {Array} gestures\n   */\n  register: function register(gesture) {\n    // add an enable gesture options if there is no given\n    var options = gesture.defaults || {};\n    if (options[gesture.name] === undefined) {\n      options[gesture.name] = true;\n    }\n\n    // extend GestureDetector default options with the GestureDetector.gesture options\n    Utils.extend(GestureDetector.defaults, options, true);\n\n    // set its index\n    gesture.index = gesture.index || 1000;\n\n    // add GestureDetector.gesture to the list\n    this.gestures.push(gesture);\n\n    // sort the list by index\n    this.gestures.sort(function(a, b) {\n      if (a.index < b.index) {\n        return -1;\n      }\n      if (a.index > b.index) {\n        return 1;\n      }\n      return 0;\n    });\n\n    return this.gestures;\n  }\n};\n\n\n/**\n * @module GestureDetector\n */\n\n/**\n * create new GestureDetector instance\n * all methods should return the instance itself, so it is chainable.\n *\n * @class Instance\n * @constructor\n * @param {HTMLElement} element\n * @param {Object} [options={}] options are merged with `GestureDetector.defaults`\n * @return {GestureDetector.Instance}\n */\nGestureDetector.Instance = function(element, options) {\n  var self = this;\n  var listenerOptions = (options && options.passive) ? { passive: true } : undefined;\n\n  // setup GestureDetectorJS window events and register all gestures\n  // this also sets up the default options\n  setup(listenerOptions);\n\n  /**\n   * @property element\n   * @type {HTMLElement}\n   */\n  this.element = element;\n\n  /**\n   * @property enabled\n   * @type {Boolean}\n   * @protected\n   */\n  this.enabled = true;\n\n  /**\n   * options, merged with the defaults\n   * options with an _ are converted to camelCase\n   * @property options\n   * @type {Object}\n   */\n  Utils.each(options, function(value, name) {\n    delete options[name];\n    options[Utils.toCamelCase(name)] = value;\n  });\n\n  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});\n  this.options.listenerOptions = listenerOptions;\n\n  // add some css to the element to prevent the browser from doing its native behavior\n  if (this.options.behavior) {\n    Utils.toggleBehavior(this.element, this.options.behavior, true);\n  }\n\n  /**\n   * event start handler on the element to start the detection\n   * @property eventStartHandler\n   * @type {Object}\n   */\n  this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {\n    if (self.enabled && ev.eventType == EVENT_START) {\n      Detection.startDetect(self, ev);\n    } else if (ev.eventType == EVENT_TOUCH) {\n      Detection.detect(ev);\n    }\n  }, listenerOptions);\n\n  /**\n   * keep a list of user event handlers which needs to be removed when calling 'dispose'\n   * @property eventHandlers\n   * @type {Array}\n   */\n  this.eventHandlers = [];\n};\n\nGestureDetector.Instance.prototype = {\n  /**\n   * @method on\n   * @signature on(gestures, handler)\n   * @description\n   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]\n   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  on: function onEvent(gestures, handler, opt) {\n    var self = this;\n\n    Event.on(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function(type) {\n      self.eventHandlers.push({ gesture: type, handler: handler });\n    });\n    return self;\n  },\n\n  /**\n   * @method off\n   * @signature off(gestures, handler)\n   * @description\n   *  [en]Remove an event listener.[/en]\n   *  [ja]イベントリスナーを削除します。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  off: function offEvent(gestures, handler, opt) {\n    var self = this;\n\n    Event.off(self.element, gestures, handler, util.extend({}, self.options.listenerOptions, opt), function(type) {\n      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);\n      if (index >= 0) {\n        self.eventHandlers.splice(index, 1);\n      }\n    });\n    return self;\n  },\n\n  /**\n   * trigger gesture event\n   * @method trigger\n   * @signature trigger(gesture, eventData)\n   * @param {String} gesture\n   * @param {Object} [eventData]\n   */\n  trigger: function triggerEvent(gesture, eventData) {\n    // optional\n    if (!eventData) {\n      eventData = {};\n    }\n\n    // create DOM event\n    var event = GestureDetector.DOCUMENT.createEvent('Event');\n    event.initEvent(gesture, true, true);\n    event.gesture = eventData;\n\n    // trigger on the target if it is in the instance element,\n    // this is for event delegation tricks\n    var element = this.element;\n    if (Utils.hasParent(eventData.target, element)) {\n      element = eventData.target;\n    }\n\n    element.dispatchEvent(event);\n    return this;\n  },\n\n  /**\n   * @method enable\n   * @signature enable(state)\n   * @description\n   *  [en]Enable or disable gesture detection.[/en]\n   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]\n   * @param {Boolean} state\n   *   [en]Specify if it should be enabled or not.[/en]\n   *   [ja]有効にするかどうかを指定します。[/ja]\n   */\n  enable: function enable(state) {\n    this.enabled = state;\n    return this;\n  },\n\n  /**\n   * @method dispose\n   * @signature dispose()\n   * @description\n   *  [en]Remove and destroy all event handlers for this instance.[/en]\n   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]\n   */\n  dispose: function dispose() {\n    var i, eh;\n\n    // undo all changes made by stop_browser_behavior\n    Utils.toggleBehavior(this.element, this.options.behavior, false);\n\n    // unbind all custom event handlers\n    for (i = -1; (eh = this.eventHandlers[++i]);) { // eslint-disable-line no-cond-assign\n      Utils.off(this.element, eh.gesture, eh.handler);\n    }\n\n    this.eventHandlers = [];\n\n    // unbind the start event listener\n    Event.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);\n\n    return null;\n  }\n};\n\n\n/**\n * @module gestures\n */\n/**\n * Move with x fingers (default 1) around on the page.\n * Preventing the default browser behavior is a good way to improve feel and working.\n * ````\n *  GestureDetectortime.on(\"drag\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Drag\n * @static\n */\n/**\n * @event drag\n * @param {Object} ev\n */\n/**\n * @event dragstart\n * @param {Object} ev\n */\n/**\n * @event dragend\n * @param {Object} ev\n */\n/**\n * @event drapleft\n * @param {Object} ev\n */\n/**\n * @event dragright\n * @param {Object} ev\n */\n/**\n * @event dragup\n * @param {Object} ev\n */\n/**\n * @event dragdown\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function(name) {\n  var triggered = false;\n\n  function dragGesture(ev, inst) {\n    var cur = Detection.current;\n\n    // max touches\n    if (inst.options.dragMaxTouches > 0 &&\n      ev.touches.length > inst.options.dragMaxTouches) {\n      return;\n    }\n\n    switch (ev.eventType) {\n    case EVENT_START:\n      triggered = false;\n      break;\n\n    case EVENT_MOVE:\n      // when the distance we moved is too small we skip this gesture\n      // or we can be already in dragging\n      if (ev.distance < inst.options.dragMinDistance &&\n        cur.name != name) {\n        return;\n      }\n\n      var startCenter = cur.startEvent.center;\n\n      // we are dragging!\n      if (cur.name != name) {\n        cur.name = name;\n        if (inst.options.dragDistanceCorrection && ev.distance > 0) {\n          // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.\n          // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.\n          // It might be useful to save the original start point somewhere\n          var factor = Math.abs(inst.options.dragMinDistance / ev.distance);\n          startCenter.pageX += ev.deltaX * factor;\n          startCenter.pageY += ev.deltaY * factor;\n          startCenter.clientX += ev.deltaX * factor;\n          startCenter.clientY += ev.deltaY * factor;\n\n          // recalculate event data using new start point\n          ev = Detection.extendEventData(ev);\n        }\n      }\n\n      // lock drag to axis?\n      if (cur.lastEvent.dragLockToAxis ||\n        ( inst.options.dragLockToAxis &&\n          inst.options.dragLockMinDistance <= ev.distance\n        )) {\n          ev.dragLockToAxis = true;\n        }\n\n        // keep direction on the axis that the drag gesture started on\n        var lastDirection = cur.lastEvent.direction;\n        if (ev.dragLockToAxis && lastDirection !== ev.direction) {\n          if (Utils.isVertical(lastDirection)) {\n            ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n          } else {\n            ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          }\n        }\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        // trigger events\n        inst.trigger(name, ev);\n        inst.trigger(name + ev.direction, ev);\n\n        var isVertical = Utils.isVertical(ev.direction);\n\n        // block the browser events\n        if ((inst.options.dragBlockVertical && isVertical) ||\n          (inst.options.dragBlockHorizontal && !isVertical)) {\n          ev.preventDefault();\n        }\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n\n      case EVENT_END:\n        triggered = false;\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Drag = {\n      name: name,\n      index: 50,\n      handler: dragGesture,\n      defaults: {\n        /**\n         * minimal movement that have to be made before the drag event gets triggered\n         * @property dragMinDistance\n         * @type {Number}\n         * @default 10\n         */\n        dragMinDistance: 10,\n\n        /**\n         * Set dragDistanceCorrection to true to make the starting point of the drag\n         * be calculated from where the drag was triggered, not from where the touch started.\n         * Useful to avoid a jerk-starting drag, which can make fine-adjustments\n         * through dragging difficult, and be visually unappealing.\n         * @property dragDistanceCorrection\n         * @type {Boolean}\n         * @default true\n         */\n        dragDistanceCorrection: true,\n\n        /**\n         * set 0 for unlimited, but this can conflict with transform\n         * @property dragMaxTouches\n         * @type {Number}\n         * @default 1\n         */\n        dragMaxTouches: 1,\n\n        /**\n         * prevent default browser behavior when dragging occurs\n         * be careful with it, it makes the element a blocking element\n         * when you are using the drag gesture, it is a good practice to set this true\n         * @property dragBlockHorizontal\n         * @type {Boolean}\n         * @default false\n         */\n        dragBlockHorizontal: false,\n\n        /**\n         * same as `dragBlockHorizontal`, but for vertical movement\n         * @property dragBlockVertical\n         * @type {Boolean}\n         * @default false\n         */\n        dragBlockVertical: false,\n\n        /**\n         * dragLockToAxis keeps the drag gesture on the axis that it started on,\n         * It disallows vertical directions if the initial direction was horizontal, and vice versa.\n         * @property dragLockToAxis\n         * @type {Boolean}\n         * @default false\n         */\n        dragLockToAxis: false,\n\n        /**\n         * drag lock only kicks in when distance > dragLockMinDistance\n         * This way, locking occurs only when the distance has become large enough to reliably determine the direction\n         * @property dragLockMinDistance\n         * @type {Number}\n         * @default 25\n         */\n        dragLockMinDistance: 25\n      }\n    };\n  })('drag');\n\n  /**\n   * @module gestures\n   */\n  /**\n   * trigger a simple gesture event, so you can do anything in your handler.\n   * only usable if you know what your doing...\n   *\n   * @class Gesture\n   * @static\n   */\n  /**\n   * @event gesture\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Gesture = {\n    name: 'gesture',\n    index: 1337,\n    handler: function releaseGesture(ev, inst) {\n      inst.trigger(this.name, ev);\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * Touch stays at the same place for x time\n   *\n   * @class Hold\n   * @static\n   */\n  /**\n   * @event hold\n   * @param {Object} ev\n   */\n\n  /**\n   * @param {String} name\n   */\n  (function(name) {\n    var timer;\n\n    function holdGesture(ev, inst) {\n      var options = inst.options,\n          current = Detection.current;\n\n      switch (ev.eventType) {\n      case EVENT_START:\n        clearTimeout(timer);\n\n        // set the gesture so we can check in the timeout if it still is\n        current.name = name;\n\n        // set timer and if after the timeout it still is hold,\n        // we trigger the hold event\n        timer = setTimeout(function() {\n          if (current && current.name == name) {\n            inst.trigger(name, ev);\n          }\n        }, options.holdTimeout);\n        break;\n\n      case EVENT_MOVE:\n        if (ev.distance > options.holdThreshold) {\n          clearTimeout(timer);\n        }\n        break;\n\n      case EVENT_RELEASE:\n        clearTimeout(timer);\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Hold = {\n      name: name,\n      index: 10,\n      defaults: {\n        /**\n         * @property holdTimeout\n         * @type {Number}\n         * @default 500\n         */\n        holdTimeout: 500,\n\n        /**\n         * movement allowed while holding\n         * @property holdThreshold\n         * @type {Number}\n         * @default 2\n         */\n        holdThreshold: 2\n      },\n      handler: holdGesture\n    };\n  })('hold');\n\n  /**\n   * @module gestures\n   */\n  /**\n   * when a touch is being released from the page\n   *\n   * @class Release\n   * @static\n   */\n  /**\n   * @event release\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n      if (ev.eventType == EVENT_RELEASE) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * triggers swipe events when the end velocity is above the threshold\n   * for best usage, set `preventDefault` (on the drag gesture) to `true`\n   * ````\n   *  GestureDetectortime.on(\"dragleft swipeleft\", function(ev) {\n   *    console.log(ev);\n   *    ev.gesture.preventDefault();\n   *  });\n   * ````\n   *\n   * @class Swipe\n   * @static\n   */\n  /**\n   * @event swipe\n   * @param {Object} ev\n   */\n  /**\n   * @event swipeleft\n   * @param {Object} ev\n   */\n  /**\n   * @event swiperight\n   * @param {Object} ev\n   */\n  /**\n   * @event swipeup\n   * @param {Object} ev\n   */\n  /**\n   * @event swipedown\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n      /**\n       * @property swipeMinTouches\n       * @type {Number}\n       * @default 1\n       */\n      swipeMinTouches: 1,\n\n      /**\n       * @property swipeMaxTouches\n       * @type {Number}\n       * @default 1\n       */\n      swipeMaxTouches: 1,\n\n      /**\n       * horizontal swipe velocity\n       * @property swipeVelocityX\n       * @type {Number}\n       * @default 0.6\n       */\n      swipeVelocityX: 0.6,\n\n      /**\n       * vertical swipe velocity\n       * @property swipeVelocityY\n       * @type {Number}\n       * @default 0.6\n       */\n      swipeVelocityY: 0.6\n    },\n\n    handler: function swipeGesture(ev, inst) {\n      if (ev.eventType == EVENT_RELEASE) {\n        var touches = ev.touches.length,\n            options = inst.options;\n\n        // max touches\n        if (touches < options.swipeMinTouches ||\n          touches > options.swipeMaxTouches) {\n          return;\n        }\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (ev.velocityX > options.swipeVelocityX ||\n          ev.velocityY > options.swipeVelocityY) {\n          // trigger swipe events\n          inst.trigger(this.name, ev);\n          inst.trigger(this.name + ev.direction, ev);\n        }\n      }\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * Single tap and a double tap on a place\n   *\n   * @class Tap\n   * @static\n   */\n  /**\n   * @event tap\n   * @param {Object} ev\n   */\n  /**\n   * @event doubletap\n   * @param {Object} ev\n   */\n\n  /**\n   * @param {String} name\n   */\n  (function(name) {\n    var hasMoved = false;\n\n    function tapGesture(ev, inst) {\n      var options = inst.options,\n          current = Detection.current,\n          prev = Detection.previous,\n          sincePrev,\n          didDoubleTap;\n\n      switch (ev.eventType) {\n      case EVENT_START:\n        hasMoved = false;\n        break;\n\n      case EVENT_MOVE:\n        hasMoved = hasMoved || (ev.distance > options.tapMaxDistance);\n        break;\n\n      case EVENT_END:\n        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {\n          // previous gesture, for the double tap since these are two different gesture detections\n          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n          didDoubleTap = false;\n\n          // check if double tap\n          if (prev && prev.name == name &&\n            (sincePrev && sincePrev < options.doubleTapInterval) &&\n            ev.distance < options.doubleTapDistance) {\n            inst.trigger('doubletap', ev);\n            didDoubleTap = true;\n          }\n\n          // do a single tap\n          if (!didDoubleTap || options.tapAlways) {\n            current.name = name;\n            inst.trigger(current.name, ev);\n          }\n        }\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Tap = {\n      name: name,\n      index: 100,\n      handler: tapGesture,\n      defaults: {\n        /**\n         * max time of a tap, this is for the slow tappers\n         * @property tapMaxTime\n         * @type {Number}\n         * @default 250\n         */\n        tapMaxTime: 250,\n\n        /**\n         * max distance of movement of a tap, this is for the slow tappers\n         * @property tapMaxDistance\n         * @type {Number}\n         * @default 10\n         */\n        tapMaxDistance: 10,\n\n        /**\n         * always trigger the `tap` event, even while double-tapping\n         * @property tapAlways\n         * @type {Boolean}\n         * @default true\n         */\n        tapAlways: true,\n\n        /**\n         * max distance between two taps\n         * @property doubleTapDistance\n         * @type {Number}\n         * @default 20\n         */\n        doubleTapDistance: 20,\n\n        /**\n         * max time between two taps\n         * @property doubleTapInterval\n         * @type {Number}\n         * @default 300\n         */\n        doubleTapInterval: 300\n      }\n    };\n  })('tap');\n\n  /**\n   * @module gestures\n   */\n  /**\n   * when a touch is being touched at the page\n   *\n   * @class Touch\n   * @static\n   */\n  /**\n   * @event touch\n   * @param {Object} ev\n   */\n  GestureDetector.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n      /**\n       * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,\n       * but it improves gestures like transforming and dragging.\n       * be careful with using this, it can be very annoying for users to be stuck on the page\n       * @property preventDefault\n       * @type {Boolean}\n       * @default false\n       */\n      preventDefault: false,\n\n      /**\n       * disable mouse events, so only touch (or pen!) input triggers events\n       * @property preventMouse\n       * @type {Boolean}\n       * @default false\n       */\n      preventMouse: false\n    },\n    handler: function touchGesture(ev, inst) {\n      if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {\n        ev.stopDetect();\n        return;\n      }\n\n      if (inst.options.preventDefault) {\n        ev.preventDefault();\n      }\n\n      if (ev.eventType == EVENT_TOUCH) {\n        inst.trigger('touch', ev);\n      }\n    }\n  };\n\n  /**\n   * @module gestures\n   */\n  /**\n   * User want to scale or rotate with 2 fingers\n   * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the\n   * `preventDefault` option.\n   *\n   * @class Transform\n   * @static\n   */\n  /**\n   * @event transform\n   * @param {Object} ev\n   */\n  /**\n   * @event transformstart\n   * @param {Object} ev\n   */\n  /**\n   * @event transformend\n   * @param {Object} ev\n   */\n  /**\n   * @event pinchin\n   * @param {Object} ev\n   */\n  /**\n   * @event pinchout\n   * @param {Object} ev\n   */\n  /**\n   * @event rotate\n   * @param {Object} ev\n   */\n\n  /**\n   * @param {String} name\n   */\n  (function(name) {\n    var triggered = false;\n\n    function transformGesture(ev, inst) {\n      switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // at least multitouch\n        if (ev.touches.length < 2) {\n          return;\n        }\n\n        var scaleThreshold = Math.abs(1 - ev.scale);\n        var rotationThreshold = Math.abs(ev.rotation);\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (scaleThreshold < inst.options.transformMinScale &&\n          rotationThreshold < inst.options.transformMinRotation) {\n          return;\n        }\n\n        // we are transforming!\n        Detection.current.name = name;\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        inst.trigger(name, ev); // basic transform event\n\n        // trigger rotate event\n        if (rotationThreshold > inst.options.transformMinRotation) {\n          inst.trigger('rotate', ev);\n        }\n\n        // trigger pinch event\n        if (scaleThreshold > inst.options.transformMinScale) {\n          inst.trigger('pinch', ev);\n          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n        }\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength < 2) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n      }\n    }\n\n    GestureDetector.gestures.Transform = {\n      name: name,\n      index: 45,\n      defaults: {\n        /**\n         * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n         * @property transformMinScale\n         * @type {Number}\n         * @default 0.01\n         */\n        transformMinScale: 0.01,\n\n        /**\n         * rotation in degrees\n         * @property transformMinRotation\n         * @type {Number}\n         * @default 1\n         */\n        transformMinRotation: 1\n      },\n\n      handler: transformGesture\n    };\n  })('transform');\n\nexport default GestureDetector;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}