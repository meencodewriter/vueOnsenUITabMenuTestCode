{"ast":null,"code":"/*\nCopyright 2013-2016 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nimport internal from '../../ons/internal/index.js';\n\n/**\n * @class AnimatorCSS - implementation of Animator class using css transitions\n */\nclass AnimatorCSS {\n  /**\n   * @method animate\n   * @desc main animation function\n   * @param {Element} element\n   * @param {Object} finalCSS\n   * @param {number} [duration=200] - duration in milliseconds\n   * @return {Object} result\n   * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped\n   * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback\n   * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds\n   * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here\n   * @example\n   * ````\n   *  var result = animator.animate(el, {opacity: 0.5}, 1000);\n   *\n   *  el.addEventListener('click', function(e){\n   *    result.speed(200).then(function(){\n   *      console.log('done');\n   *    });\n   *  }, 300);\n   * ````\n   */\n  animate(el, final, duration = 200) {\n    var start = new Date().getTime(),\n      initial = {},\n      stopped = false,\n      next = false,\n      timeout = false,\n      properties = Object.keys(final);\n    var updateStyles = () => {\n      let s = window.getComputedStyle(el);\n      properties.forEach(s.getPropertyValue.bind(s));\n      s = el.offsetHeight;\n    };\n    var result = {\n      stop: (options = {}) => {\n        timeout && clearTimeout(timeout);\n        var k = Math.min(1, (new Date().getTime() - start) / duration);\n        properties.forEach(i => {\n          el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');\n        });\n        el.style.transitionDuration = '0s';\n        if (options.stopNext) {\n          next = false;\n        } else if (!stopped) {\n          stopped = true;\n          next && next();\n        }\n        return result;\n      },\n      then: cb => {\n        next = cb;\n        if (stopped) {\n          next && next();\n        }\n        return result;\n      },\n      speed: newDuration => {\n        if (internal.config.animationsDisabled) {\n          newDuration = 0;\n        }\n        if (!stopped) {\n          timeout && clearTimeout(timeout);\n          const passed = new Date().getTime() - start;\n          const k = passed / duration;\n          const remaining = newDuration * (1 - k);\n          properties.forEach(i => {\n            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');\n          });\n          updateStyles();\n          start = el.speedUpTime;\n          duration = remaining;\n          el.style.transitionDuration = duration / 1000 + 's';\n          properties.forEach(i => {\n            el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');\n          });\n          timeout = setTimeout(result.stop, remaining);\n        }\n        return result;\n      },\n      finish: (milliseconds = 50) => {\n        var k = (new Date().getTime() - start) / duration;\n        result.speed(milliseconds / (1 - k));\n        return result;\n      }\n    };\n    if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {\n      return result;\n    }\n    var style = window.getComputedStyle(el);\n    properties.forEach(e => {\n      const v = parseFloat(style.getPropertyValue(e));\n      initial[e] = isNaN(v) ? 0 : v;\n    });\n    if (!stopped) {\n      el.style.transitionProperty = properties.join(',');\n      el.style.transitionDuration = duration / 1000 + 's';\n      properties.forEach(e => {\n        el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');\n      });\n    }\n    timeout = setTimeout(result.stop, duration);\n    this._onStopAnimations(el, result.stop);\n    return result;\n  }\n  constructor() {\n    this._queue = [];\n    this._index = 0;\n  }\n  _onStopAnimations(el, listener) {\n    var queue = this._queue;\n    var i = this._index++;\n    queue[el] = queue[el] || [];\n    queue[el][i] = options => {\n      delete queue[el][i];\n      if (queue[el] && queue[el].length == 0) {\n        delete queue[el];\n      }\n      return listener(options);\n    };\n  }\n\n  /**\n  * @method stopAnimations\n  * @desc stops active animations on a specified element\n  * @param {Element|Array} element - element or array of elements\n  * @param {Object} [options={}]\n  * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true\n  */\n  stopAnimations(el, options = {}) {\n    if (Array.isArray(el)) {\n      return el.forEach(el => {\n        this.stopAnimations(el, options);\n      });\n    }\n    (this._queue[el] || []).forEach(e => {\n      e(options || {});\n    });\n  }\n\n  /**\n  * @method stopAll\n  * @desc stops all active animations\n  * @param {Object} [options={}]\n  * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true\n  */\n  stopAll(options = {}) {\n    this.stopAnimations(Object.keys(this._queue), options);\n  }\n\n  /**\n  * @method fade\n  * @desc fades the element (short version for animate(el, {opacity: 0}))\n  * @param {Element} element\n  * @param {number} [duration=200]\n  */\n  fade(el, duration = 200) {\n    return this.animate(el, {\n      opacity: 0\n    }, duration);\n  }\n}\nexport default AnimatorCSS;","map":{"version":3,"names":["internal","AnimatorCSS","animate","el","final","duration","start","Date","getTime","initial","stopped","next","timeout","properties","Object","keys","updateStyles","s","window","getComputedStyle","forEach","getPropertyValue","bind","offsetHeight","result","stop","options","clearTimeout","k","Math","min","i","style","transitionDuration","stopNext","then","cb","speed","newDuration","config","animationsDisabled","passed","remaining","speedUpTime","setTimeout","finish","milliseconds","hasAttribute","e","v","parseFloat","isNaN","transitionProperty","join","_onStopAnimations","constructor","_queue","_index","listener","queue","length","stopAnimations","Array","isArray","stopAll","fade","opacity"],"sources":["/Users/meenho/Documents/A_techlmh/vueTests/vueOnsenUITabMenuTestCode/my-onsen-app/node_modules/onsenui/esm/elements/ons-ripple/animator-css.js"],"sourcesContent":["/*\nCopyright 2013-2016 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nimport internal from '../../ons/internal/index.js';\n\n/**\n * @class AnimatorCSS - implementation of Animator class using css transitions\n */\nclass AnimatorCSS {\n\n  /**\n   * @method animate\n   * @desc main animation function\n   * @param {Element} element\n   * @param {Object} finalCSS\n   * @param {number} [duration=200] - duration in milliseconds\n   * @return {Object} result\n   * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped\n   * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback\n   * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds\n   * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here\n   * @example\n   * ````\n   *  var result = animator.animate(el, {opacity: 0.5}, 1000);\n   *\n   *  el.addEventListener('click', function(e){\n   *    result.speed(200).then(function(){\n   *      console.log('done');\n   *    });\n   *  }, 300);\n   * ````\n   */\n  animate(el, final, duration = 200) {\n    var start = (new Date()).getTime(),\n        initial = {},\n        stopped = false,\n        next = false,\n        timeout = false,\n        properties = Object.keys(final);\n\n    var updateStyles = () => {\n      let s = window.getComputedStyle(el);\n      properties.forEach(s.getPropertyValue.bind(s));\n      s = el.offsetHeight;\n    };\n\n    var result = {\n      stop: (options = {}) => {\n        timeout && clearTimeout(timeout);\n        var k = Math.min(1, ((new Date()).getTime() - start) / duration);\n        properties.forEach(i => {\n          el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');\n        });\n        el.style.transitionDuration = '0s';\n\n        if (options.stopNext) {\n          next = false;\n        } else if (!stopped) {\n          stopped = true;\n          next && next();\n        }\n        return result;\n      },\n      then: (cb) => {\n        next = cb;\n        if (stopped) {\n          next && next();\n        }\n        return result;\n      },\n      speed: (newDuration) => {\n        if (internal.config.animationsDisabled) {\n          newDuration = 0;\n        }\n        if (!stopped) {\n          timeout && clearTimeout(timeout);\n\n          const passed = (new Date()).getTime() - start;\n          const  k = passed / duration;\n          const remaining = newDuration * (1 - k);\n\n          properties.forEach(i => {\n            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');\n          });\n\n          updateStyles();\n\n          start = el.speedUpTime;\n          duration = remaining;\n\n          el.style.transitionDuration = duration / 1000 + 's';\n\n          properties.forEach(i => {\n            el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');\n          });\n\n          timeout = setTimeout(result.stop, remaining);\n        }\n        return result;\n      },\n      finish: (milliseconds = 50) => {\n        var k = ((new Date()).getTime() - start) / duration;\n\n        result.speed(milliseconds / (1 - k));\n        return result;\n      }\n    };\n\n    if (el.hasAttribute('disabled') || stopped || internal.config.animationsDisabled) {\n      return result;\n    }\n\n    var style = window.getComputedStyle(el);\n    properties.forEach(e => {\n      const v = parseFloat(style.getPropertyValue(e));\n      initial[e] = isNaN(v) ? 0 : v;\n    });\n\n\n    if (!stopped) {\n      el.style.transitionProperty = properties.join(',');\n      el.style.transitionDuration = duration / 1000 + 's';\n\n      properties.forEach(e => {\n        el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');\n      });\n    }\n\n    timeout = setTimeout(result.stop, duration);\n    this._onStopAnimations(el, result.stop);\n\n    return result;\n  }\n\n  constructor() {\n    this._queue = [];\n    this._index = 0;\n  }\n\n  _onStopAnimations(el, listener) {\n    var queue = this._queue;\n    var i = this._index++;\n    queue[el] = queue[el] || [];\n    queue[el][i] = (options) => {\n      delete queue[el][i];\n      if (queue[el] && queue[el].length == 0) {\n        delete queue[el];\n      }\n      return listener(options);\n    };\n  }\n\n  /**\n  * @method stopAnimations\n  * @desc stops active animations on a specified element\n  * @param {Element|Array} element - element or array of elements\n  * @param {Object} [options={}]\n  * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true\n  */\n  stopAnimations(el, options = {}) {\n    if (Array.isArray(el)) {\n      return el.forEach(el => {\n        this.stopAnimations(el, options);\n      });\n    }\n\n    (this._queue[el] || []).forEach(e => { e(options || {}); });\n  }\n\n  /**\n  * @method stopAll\n  * @desc stops all active animations\n  * @param {Object} [options={}]\n  * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true\n  */\n  stopAll(options = {}) {\n    this.stopAnimations(Object.keys(this._queue), options);\n  }\n\n  /**\n  * @method fade\n  * @desc fades the element (short version for animate(el, {opacity: 0}))\n  * @param {Element} element\n  * @param {number} [duration=200]\n  */\n  fade(el, duration = 200) {\n    return this.animate(el, {opacity: 0}, duration);\n  }\n\n}\n\nexport default AnimatorCSS;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}