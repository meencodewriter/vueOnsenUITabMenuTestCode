{"ast":null,"code":"import \"core-js/modules/web.immediate.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport util from '../util.js';\nimport platform from '../platform.js';\nimport animit from '../animit.js';\nimport GestureDetector from '../gesture-detector.js';\nconst directionMap = {\n  vertical: {\n    axis: 'Y',\n    size: 'Height',\n    dir: ['up', 'down'],\n    t3d: ['0px, ', 'px, 0px']\n  },\n  horizontal: {\n    axis: 'X',\n    size: 'Width',\n    dir: ['left', 'right'],\n    t3d: ['', 'px, 0px, 0px']\n  }\n};\nexport default class Swiper {\n  constructor(params) {\n    // Parameters\n    const FALSE = () => false;\n    `getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook`.split(/\\s+/).forEach(key => this[key] = params[key] || FALSE);\n    this.getElement = params.getElement; // Required\n    this.scrollHook = params.scrollHook; // Optional\n    this.itemSize = params.itemSize || '100%';\n    this.getAutoScrollRatio = (...args) => {\n      let ratio = params.getAutoScrollRatio && params.getAutoScrollRatio(...args);\n      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;\n      if (ratio < 0.0 || ratio > 1.0) {\n        util.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');\n      }\n      return ratio;\n    };\n\n    // Prevent clicks only on desktop\n    this.shouldBlock = util.globals.actualMobileOS === 'other';\n\n    // Bind handlers\n    this.onDragStart = this.onDragStart.bind(this);\n    this.onDrag = this.onDrag.bind(this);\n    this.onDragEnd = this.onDragEnd.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this._shouldFixScroll = util.globals.actualMobileOS === 'ios';\n  }\n  init({\n    swipeable,\n    autoRefresh\n  } = {}) {\n    this.initialized = true;\n    this.target = this.getElement().children[0];\n    this.blocker = this.getElement().children[1];\n    if (!this.target || !this.blocker) {\n      util.throw('Expected \"target\" and \"blocker\" elements to exist before initializing Swiper');\n    }\n    if (!this.shouldBlock) {\n      this.blocker.style.display = 'none';\n    }\n\n    // Add classes\n    this.getElement().classList.add('ons-swiper');\n    this.target.classList.add('ons-swiper-target');\n    this.blocker.classList.add('ons-swiper-blocker');\n\n    // Setup listeners\n    this._gestureDetector = new GestureDetector(this.getElement(), {\n      dragMinDistance: 1,\n      dragLockToAxis: true,\n      passive: !this._shouldFixScroll\n    });\n    this._mutationObserver = new MutationObserver(() => this.refresh());\n    this.updateSwipeable(swipeable);\n    this.updateAutoRefresh(autoRefresh);\n\n    // Setup initial layout\n    this._scroll = this._offset = this._lastActiveIndex = 0;\n    this._updateLayout();\n    this._setupInitialIndex();\n    setImmediate(() => this.initialized && this._setupInitialIndex());\n\n    // Fix rendering glitch on Android 4.1\n    // Fix for iframes where the width is inconsistent at the beginning\n    if (window !== window.parent || this.offsetHeight === 0) {\n      window.requestAnimationFrame(() => this.initialized && this.onResize());\n    }\n  }\n  dispose() {\n    this.initialized = false;\n    this.updateSwipeable(false);\n    this.updateAutoRefresh(false);\n    this._gestureDetector && this._gestureDetector.dispose();\n    this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;\n    this.setupResize(false);\n  }\n  onResize() {\n    const i = this._scroll / this.itemNumSize;\n    this._reset();\n    this.setActiveIndex(i);\n    this.refresh();\n  }\n  get itemCount() {\n    return this.target.children.length;\n  }\n  get itemNumSize() {\n    if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {\n      this._itemNumSize = this._calculateItemSize();\n    }\n    return this._itemNumSize;\n  }\n  get maxScroll() {\n    const max = this.itemCount * this.itemNumSize - this.targetSize;\n    return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.\n  }\n\n  _calculateItemSize() {\n    const matches = this.itemSize.match(/^(\\d+)(px|%)/);\n    if (!matches) {\n      util.throw(`Invalid state: swiper's size unit must be '%' or 'px'`);\n    }\n    const value = parseInt(matches[1], 10);\n    return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;\n  }\n  _setupInitialIndex() {\n    this._reset();\n    this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);\n    this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;\n    this._scrollTo(this._scroll);\n  }\n  _setSwiping(toggle) {\n    this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages\n  }\n\n  setActiveIndex(index, options = {}) {\n    this._setSwiping(true);\n    index = Math.max(0, Math.min(index, this.itemCount - 1));\n    const scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));\n    return this._changeTo(scroll, options);\n  }\n  getActiveIndex(scroll = this._scroll) {\n    scroll -= this._offset;\n    const count = this.itemCount,\n      size = this.itemNumSize;\n    if (this.itemNumSize === 0 || !util.isInteger(scroll)) {\n      return this._lastActiveIndex;\n    }\n    if (scroll <= 0) {\n      return 0;\n    }\n    for (let i = 0; i < count; i++) {\n      if (size * i <= scroll && size * (i + 1) > scroll) {\n        return i;\n      }\n    }\n    return count - 1;\n  }\n  setupResize(add) {\n    window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);\n  }\n  show() {\n    this.setupResize(true);\n    this.onResize();\n    setTimeout(() => this.target && this.target.classList.add('active'), 1000 / 60); // Hide elements after animations\n  }\n\n  hide() {\n    this.setupResize(false);\n    this.target.classList.remove('active'); // Show elements before animations\n  }\n\n  updateSwipeable(shouldUpdate) {\n    if (this._gestureDetector) {\n      const action = shouldUpdate ? 'on' : 'off';\n      this._gestureDetector[action]('drag', this.onDrag);\n      this._gestureDetector[action]('dragstart', this.onDragStart);\n      this._gestureDetector[action]('dragend', this.onDragEnd);\n    }\n  }\n  updateAutoRefresh(shouldWatch) {\n    if (this._mutationObserver) {\n      shouldWatch ? this._mutationObserver.observe(this.target, {\n        childList: true\n      }) : this._mutationObserver.disconnect();\n    }\n  }\n  updateItemSize(newSize) {\n    this.itemSize = newSize || '100%';\n    this.refresh();\n  }\n  toggleBlocker(block) {\n    this.blocker.style.pointerEvents = block ? 'auto' : 'none';\n  }\n  _canConsumeGesture(gesture) {\n    const d = gesture.direction;\n    const isFirst = this._scroll === 0 && !this.isOverScrollable();\n    const isLast = this._scroll === this.maxScroll && !this.isOverScrollable();\n    return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;\n  }\n  onDragStart(event) {\n    this._ignoreDrag = event.consumed || !util.isValidGesture(event);\n    if (!this._ignoreDrag) {\n      const consume = event.consume;\n      event.consume = () => {\n        consume && consume();\n        this._ignoreDrag = true;\n      };\n      if (this._canConsumeGesture(event.gesture)) {\n        const startX = event.gesture.center && event.gesture.center.clientX || 0,\n          distFromEdge = this.getBubbleWidth() || 0,\n          start = () => {\n            consume && consume();\n            event.consumed = true;\n            this._started = true; // Avoid starting drag from outside\n            this.shouldBlock && this.toggleBlocker(true);\n            this._setSwiping(true);\n            util.iosPreventScroll(this._gestureDetector);\n          };\n\n        // Let parent elements consume the gesture or consume it right away\n        startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(() => !this._ignoreDrag && start()) : start();\n      }\n    }\n  }\n  onDrag(event) {\n    if (!event.gesture || this._ignoreDrag || !this._started) {\n      return;\n    }\n    this._continued = true; // Fix for random 'dragend' without 'drag'\n    event.stopPropagation();\n    this._scrollTo(this._scroll - this._getDelta(event), {\n      throttle: true\n    });\n  }\n  onDragEnd(event) {\n    this._started = false;\n    if (!event.gesture || this._ignoreDrag || !this._continued) {\n      this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate\n      return;\n    }\n    this._continued = false;\n    event.stopPropagation();\n    const scroll = this._scroll - this._getDelta(event);\n    const normalizedScroll = this._normalizeScroll(scroll);\n    scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);\n    this.shouldBlock && this.toggleBlocker(false);\n  }\n  _startMomentumScroll(scroll, event) {\n    const velocity = this._getVelocity(event),\n      matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];\n    const nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);\n    let duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;\n    duration = Math.min(.25, Math.max(.1, duration));\n    this._changeTo(nextScroll, {\n      swipe: true,\n      animationOptions: {\n        duration,\n        timing: 'cubic-bezier(.4, .7, .5, 1)'\n      }\n    });\n  }\n  _killOverScroll(scroll) {\n    this._scroll = scroll;\n    const direction = this.dM.dir[Number(scroll > 0)];\n    const killOverScroll = () => this._changeTo(scroll, {\n      animationOptions: {\n        duration: .4,\n        timing: 'cubic-bezier(.1, .4, .1, 1)'\n      }\n    });\n    this.overScrollHook({\n      direction,\n      killOverScroll\n    }) || killOverScroll();\n  }\n  _changeTo(scroll, options = {}) {\n    const e = {\n      activeIndex: this.getActiveIndex(scroll),\n      lastActiveIndex: this._lastActiveIndex,\n      swipe: options.swipe || false\n    };\n    const change = e.activeIndex !== e.lastActiveIndex;\n    const canceled = change ? this.preChangeHook(e) : false;\n    this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;\n    this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;\n    return this._scrollTo(this._scroll, options).then(() => {\n      if (scroll === this._scroll && !canceled) {\n        this._setSwiping(false);\n        change && this.postChangeHook(e);\n      } else if (options.reject) {\n        this._setSwiping(false);\n        return Promise.reject('Canceled');\n      }\n    });\n  }\n  _scrollTo(scroll, options = {}) {\n    if (options.throttle) {\n      const ratio = 0.35;\n      if (scroll < 0) {\n        scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;\n      } else {\n        const maxScroll = this.maxScroll;\n        if (maxScroll < scroll) {\n          scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;\n        }\n      }\n    }\n    const opt = options.animation === 'none' ? {} : options.animationOptions;\n    this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});\n    return new Promise(resolve => animit(this.target).queue({\n      transform: this._getTransform(scroll)\n    }, opt).play(resolve));\n  }\n  _getAutoScroll(scroll, velocity, matchesDirection) {\n    const max = this.maxScroll,\n      offset = this._offset,\n      size = this.itemNumSize;\n    if (!this.isAutoScrollable()) {\n      return Math.max(0, Math.min(max, scroll));\n    }\n    let arr = [];\n    for (let s = offset; s < max; s += size) {\n      arr.push(s);\n    }\n    arr.push(max);\n    arr = arr.sort((left, right) => Math.abs(left - scroll) - Math.abs(right - scroll)).filter((item, pos) => !pos || item !== arr[pos - 1]);\n    let result = arr[0];\n    const lastScroll = this._lastActiveIndex * size + offset;\n    const scrollRatio = Math.abs(scroll - lastScroll) / size;\n    if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {\n      result = lastScroll;\n    } else {\n      if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {\n        result = arr[1];\n      }\n    }\n    return Math.max(0, Math.min(max, result));\n  }\n  _reset() {\n    this._targetSize = this._itemNumSize = undefined;\n  }\n  _normalizeScroll(scroll) {\n    return Math.max(Math.min(scroll, this.maxScroll), 0);\n  }\n  refresh() {\n    this._reset();\n    this._updateLayout();\n    if (util.isInteger(this._scroll)) {\n      const scroll = this._normalizeScroll(this._scroll);\n      scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);\n    } else {\n      this._setupInitialIndex();\n    }\n    this.refreshHook();\n  }\n  get targetSize() {\n    if (!this._targetSize) {\n      this._targetSize = this.target[`offset${this.dM.size}`];\n    }\n    return this._targetSize;\n  }\n  _getDelta(event) {\n    return event.gesture[`delta${this.dM.axis}`];\n  }\n  _getVelocity(event) {\n    return event.gesture[`velocity${this.dM.axis}`];\n  }\n  _getTransform(scroll) {\n    return `translate3d(${this.dM.t3d[0]}${-scroll}${this.dM.t3d[1]})`;\n  }\n  _updateLayout() {\n    this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];\n    this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());\n    for (let c = this.target.children[0]; c; c = c.nextElementSibling) {\n      c.style[this.dM.size.toLowerCase()] = this.itemSize;\n    }\n    if (this.isCentered()) {\n      this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;\n    }\n  }\n}","map":{"version":3,"names":["util","platform","animit","GestureDetector","directionMap","vertical","axis","size","dir","t3d","horizontal","Swiper","constructor","params","FALSE","split","forEach","key","getElement","scrollHook","itemSize","getAutoScrollRatio","args","ratio","throw","shouldBlock","globals","actualMobileOS","onDragStart","bind","onDrag","onDragEnd","onResize","_shouldFixScroll","init","swipeable","autoRefresh","initialized","target","children","blocker","style","display","classList","add","_gestureDetector","dragMinDistance","dragLockToAxis","passive","_mutationObserver","MutationObserver","refresh","updateSwipeable","updateAutoRefresh","_scroll","_offset","_lastActiveIndex","_updateLayout","_setupInitialIndex","setImmediate","window","parent","offsetHeight","requestAnimationFrame","dispose","setupResize","i","itemNumSize","_reset","setActiveIndex","itemCount","length","_itemNumSize","_calculateItemSize","maxScroll","max","targetSize","Math","ceil","matches","match","value","parseInt","round","min","Number","getInitialIndex","_scrollTo","_setSwiping","toggle","index","options","scroll","_changeTo","getActiveIndex","count","isInteger","show","setTimeout","hide","remove","shouldUpdate","action","shouldWatch","observe","childList","disconnect","updateItemSize","newSize","toggleBlocker","block","pointerEvents","_canConsumeGesture","gesture","d","direction","isFirst","isOverScrollable","isLast","isVertical","event","_ignoreDrag","consumed","isValidGesture","consume","startX","center","clientX","distFromEdge","getBubbleWidth","start","_started","iosPreventScroll","_continued","stopPropagation","_getDelta","throttle","normalizedScroll","_normalizeScroll","_startMomentumScroll","_killOverScroll","velocity","_getVelocity","matchesDirection","interimDirection","dM","nextScroll","_getAutoScroll","duration","abs","swipe","animationOptions","timing","killOverScroll","overScrollHook","e","activeIndex","lastActiveIndex","change","canceled","preChangeHook","then","postChangeHook","reject","Promise","opt","animation","toFixed","resolve","queue","transform","_getTransform","play","offset","isAutoScrollable","arr","s","push","sort","left","right","filter","item","pos","result","lastScroll","scrollRatio","_targetSize","undefined","refreshHook","c","nextElementSibling","toLowerCase","isCentered"],"sources":["/Users/meenho/Documents/A_techlmh/vueTests/my-onsen-app/node_modules/onsenui/esm/ons/internal/swiper.js"],"sourcesContent":["import util from '../util.js';\nimport platform from '../platform.js';\nimport animit from '../animit.js';\nimport GestureDetector from '../gesture-detector.js';\n\nconst directionMap = {\n  vertical: {\n    axis: 'Y',\n    size: 'Height',\n    dir: ['up', 'down'],\n    t3d: ['0px, ', 'px, 0px']\n  },\n  horizontal: {\n    axis: 'X',\n    size: 'Width',\n    dir: ['left', 'right'],\n    t3d: ['', 'px, 0px, 0px']\n  }\n};\n\nexport default class Swiper {\n  constructor(params) {\n    // Parameters\n    const FALSE = (() => false);\n    `getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook`\n      .split(/\\s+/)\n      .forEach(key => this[key] = params[key] || FALSE);\n\n    this.getElement = params.getElement; // Required\n    this.scrollHook = params.scrollHook; // Optional\n    this.itemSize = params.itemSize || '100%';\n\n    this.getAutoScrollRatio = (...args) => {\n      let ratio = params.getAutoScrollRatio && params.getAutoScrollRatio(...args);\n      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;\n      if (ratio < 0.0 || ratio > 1.0) {\n        util.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');\n      }\n      return ratio;\n    };\n\n    // Prevent clicks only on desktop\n    this.shouldBlock = util.globals.actualMobileOS === 'other';\n\n    // Bind handlers\n    this.onDragStart = this.onDragStart.bind(this);\n    this.onDrag = this.onDrag.bind(this);\n    this.onDragEnd = this.onDragEnd.bind(this);\n    this.onResize = this.onResize.bind(this);\n\n    this._shouldFixScroll = util.globals.actualMobileOS === 'ios';\n  }\n\n  init({ swipeable, autoRefresh } = {}) {\n    this.initialized = true;\n    this.target = this.getElement().children[0];\n    this.blocker = this.getElement().children[1];\n    if (!this.target || !this.blocker) {\n      util.throw('Expected \"target\" and \"blocker\" elements to exist before initializing Swiper');\n    }\n\n    if (!this.shouldBlock) {\n      this.blocker.style.display = 'none';\n    }\n\n    // Add classes\n    this.getElement().classList.add('ons-swiper');\n    this.target.classList.add('ons-swiper-target');\n    this.blocker.classList.add('ons-swiper-blocker');\n\n    // Setup listeners\n    this._gestureDetector = new GestureDetector(this.getElement(),\n      { dragMinDistance: 1, dragLockToAxis: true, passive: !this._shouldFixScroll }\n    );\n    this._mutationObserver = new MutationObserver(() => this.refresh());\n    this.updateSwipeable(swipeable);\n    this.updateAutoRefresh(autoRefresh);\n\n    // Setup initial layout\n    this._scroll = this._offset = this._lastActiveIndex = 0;\n    this._updateLayout();\n    this._setupInitialIndex();\n    setImmediate(() => this.initialized && this._setupInitialIndex());\n\n    // Fix rendering glitch on Android 4.1\n    // Fix for iframes where the width is inconsistent at the beginning\n    if (window !== window.parent || this.offsetHeight === 0) {\n      window.requestAnimationFrame(() => this.initialized && this.onResize());\n    }\n  }\n\n  dispose() {\n    this.initialized = false;\n    this.updateSwipeable(false);\n    this.updateAutoRefresh(false);\n\n    this._gestureDetector && this._gestureDetector.dispose();\n    this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;\n\n    this.setupResize(false);\n  }\n\n  onResize() {\n    const i = this._scroll / this.itemNumSize;\n    this._reset();\n    this.setActiveIndex(i);\n    this.refresh();\n  }\n\n  get itemCount() {\n    return this.target.children.length;\n  }\n\n  get itemNumSize() {\n    if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {\n      this._itemNumSize = this._calculateItemSize();\n    }\n    return this._itemNumSize;\n  }\n\n  get maxScroll() {\n    const max = this.itemCount * this.itemNumSize - this.targetSize;\n    return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.\n  }\n\n  _calculateItemSize() {\n    const matches = this.itemSize.match(/^(\\d+)(px|%)/);\n\n    if (!matches) {\n      util.throw(`Invalid state: swiper's size unit must be '%' or 'px'`);\n    }\n\n    const value = parseInt(matches[1], 10);\n    return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;\n  }\n\n  _setupInitialIndex() {\n    this._reset();\n    this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);\n    this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;\n    this._scrollTo(this._scroll);\n  }\n\n  _setSwiping(toggle) {\n    this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages\n  }\n\n  setActiveIndex(index, options = {}) {\n    this._setSwiping(true);\n    index = Math.max(0, Math.min(index, this.itemCount - 1));\n    const scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));\n\n    return this._changeTo(scroll, options);\n  }\n\n  getActiveIndex(scroll = this._scroll) {\n    scroll -= this._offset;\n    const count = this.itemCount,\n      size = this.itemNumSize;\n\n    if (this.itemNumSize === 0 || !util.isInteger(scroll)) {\n      return this._lastActiveIndex;\n    }\n\n    if (scroll <= 0) {\n      return 0;\n    }\n\n    for (let i = 0; i < count; i++) {\n      if (size * i <= scroll && size * (i + 1) > scroll) {\n        return i;\n      }\n    }\n\n    return count - 1;\n  }\n\n  setupResize(add) {\n    window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);\n  }\n\n  show() {\n    this.setupResize(true);\n    this.onResize();\n    setTimeout(() => this.target && this.target.classList.add('active'), 1000/60); // Hide elements after animations\n  }\n\n  hide() {\n    this.setupResize(false);\n    this.target.classList.remove('active'); // Show elements before animations\n  }\n\n  updateSwipeable(shouldUpdate) {\n    if (this._gestureDetector) {\n      const action = shouldUpdate ? 'on' : 'off';\n      this._gestureDetector[action]('drag', this.onDrag);\n      this._gestureDetector[action]('dragstart', this.onDragStart);\n      this._gestureDetector[action]('dragend', this.onDragEnd);\n    }\n  }\n\n  updateAutoRefresh(shouldWatch) {\n    if (this._mutationObserver) {\n      shouldWatch\n        ? this._mutationObserver.observe(this.target, { childList: true })\n        : this._mutationObserver.disconnect();\n    }\n  }\n\n  updateItemSize(newSize) {\n    this.itemSize = newSize || '100%';\n    this.refresh();\n  }\n\n  toggleBlocker(block) {\n    this.blocker.style.pointerEvents = block ? 'auto' : 'none';\n  }\n\n  _canConsumeGesture(gesture) {\n    const d = gesture.direction;\n    const isFirst = this._scroll === 0 && !this.isOverScrollable();\n    const isLast = this._scroll === this.maxScroll && !this.isOverScrollable();\n\n    return this.isVertical()\n      ? ((d === 'down' && !isFirst) || (d === 'up' && !isLast))\n      : ((d === 'right' && !isFirst) || (d === 'left' && !isLast));\n  }\n\n  onDragStart(event) {\n    this._ignoreDrag = event.consumed || !util.isValidGesture(event);\n\n    if (!this._ignoreDrag) {\n      const consume = event.consume;\n      event.consume = () => { consume && consume(); this._ignoreDrag = true; };\n\n      if (this._canConsumeGesture(event.gesture)) {\n        const startX = event.gesture.center && event.gesture.center.clientX || 0,\n          distFromEdge = this.getBubbleWidth() || 0,\n          start = () => {\n            consume && consume();\n            event.consumed = true;\n            this._started = true; // Avoid starting drag from outside\n            this.shouldBlock && this.toggleBlocker(true);\n            this._setSwiping(true);\n            util.iosPreventScroll(this._gestureDetector);\n          };\n\n        // Let parent elements consume the gesture or consume it right away\n        startX < distFromEdge || startX > (this.targetSize - distFromEdge)\n          ? setImmediate(() => !this._ignoreDrag && start())\n          : start();\n      }\n    }\n  }\n\n  onDrag(event) {\n    if (!event.gesture || this._ignoreDrag || !this._started) {\n      return;\n    }\n\n    this._continued = true; // Fix for random 'dragend' without 'drag'\n    event.stopPropagation();\n\n    this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });\n  }\n\n  onDragEnd(event) {\n    this._started = false;\n    if (!event.gesture || this._ignoreDrag || !this._continued) {\n      this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate\n      return;\n    }\n\n    this._continued = false;\n    event.stopPropagation();\n\n    const scroll = this._scroll - this._getDelta(event);\n    const normalizedScroll = this._normalizeScroll(scroll);\n    scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);\n    this.shouldBlock && this.toggleBlocker(false);\n  }\n\n  _startMomentumScroll(scroll, event) {\n    const velocity = this._getVelocity(event),\n      matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];\n\n    const nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);\n    let duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;\n    duration = Math.min(.25, Math.max(.1, duration));\n\n    this._changeTo(nextScroll, { swipe: true, animationOptions: { duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });\n  }\n\n  _killOverScroll(scroll) {\n    this._scroll = scroll;\n    const direction = this.dM.dir[Number(scroll > 0)];\n    const killOverScroll = () => this._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });\n    this.overScrollHook({ direction, killOverScroll }) || killOverScroll();\n  }\n\n  _changeTo(scroll, options = {}) {\n    const e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };\n    const change = e.activeIndex !== e.lastActiveIndex;\n    const canceled = change ? this.preChangeHook(e) : false;\n\n    this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;\n    this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;\n\n    return this._scrollTo(this._scroll, options).then(() => {\n      if (scroll === this._scroll && !canceled) {\n        this._setSwiping(false);\n        change && this.postChangeHook(e);\n      } else if (options.reject) {\n        this._setSwiping(false);\n        return Promise.reject('Canceled');\n      }\n    });\n  }\n\n  _scrollTo(scroll, options = {}) {\n    if (options.throttle) {\n      const ratio = 0.35;\n      if (scroll < 0) {\n        scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;\n      } else {\n        const maxScroll = this.maxScroll;\n        if (maxScroll < scroll) {\n          scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;\n        }\n      }\n    }\n\n    const opt = options.animation  === 'none' ? {} : options.animationOptions;\n    this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});\n\n    return new Promise(resolve =>\n      animit(this.target)\n        .queue({ transform: this._getTransform(scroll) }, opt)\n        .play(resolve)\n    );\n  }\n\n  _getAutoScroll(scroll, velocity, matchesDirection) {\n    const max = this.maxScroll,\n      offset = this._offset,\n      size = this.itemNumSize;\n\n    if (!this.isAutoScrollable()) {\n      return Math.max(0, Math.min(max, scroll));\n    }\n\n    let arr = [];\n    for (let s = offset; s < max; s += size) {\n      arr.push(s);\n    }\n    arr.push(max);\n\n    arr = arr\n      .sort((left, right) => Math.abs(left - scroll) - Math.abs(right - scroll))\n      .filter((item, pos) => !pos || item !== arr[pos - 1]);\n\n    let result = arr[0];\n    const lastScroll = this._lastActiveIndex * size + offset;\n    const scrollRatio = Math.abs(scroll - lastScroll) / size;\n\n    if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {\n      result = lastScroll;\n    } else {\n      if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {\n        result = arr[1];\n      }\n    }\n    return Math.max(0, Math.min(max, result));\n  }\n\n  _reset() {\n    this._targetSize = this._itemNumSize = undefined;\n  }\n\n  _normalizeScroll(scroll) {\n    return Math.max( Math.min(scroll, this.maxScroll), 0);\n  }\n\n  refresh() {\n    this._reset();\n    this._updateLayout();\n\n    if (util.isInteger(this._scroll)) {\n      const scroll = this._normalizeScroll(this._scroll);\n      scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);\n    } else {\n      this._setupInitialIndex();\n    }\n\n    this.refreshHook();\n  }\n\n  get targetSize() {\n    if (!this._targetSize) {\n      this._targetSize = this.target[`offset${this.dM.size}`];\n    }\n    return this._targetSize;\n  }\n\n  _getDelta(event) {\n    return event.gesture[`delta${this.dM.axis}`];\n  }\n\n  _getVelocity(event) {\n    return event.gesture[`velocity${this.dM.axis}`];\n  }\n\n  _getTransform(scroll) {\n    return `translate3d(${this.dM.t3d[0]}${-scroll}${this.dM.t3d[1]})`;\n  }\n\n  _updateLayout() {\n    this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];\n    this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());\n\n    for (let c = this.target.children[0]; c; c = c.nextElementSibling) {\n      c.style[this.dM.size.toLowerCase()] = this.itemSize;\n    }\n\n    if (this.isCentered()) {\n      this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;\n    }\n  }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}